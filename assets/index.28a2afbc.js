const fs=function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))n(r);new MutationObserver(r=>{for(const s of r)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&n(a)}).observe(document,{childList:!0,subtree:!0});function t(r){const s={};return r.integrity&&(s.integrity=r.integrity),r.referrerpolicy&&(s.referrerPolicy=r.referrerpolicy),r.crossorigin==="use-credentials"?s.credentials="include":r.crossorigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(r){if(r.ep)return;r.ep=!0;const s=t(r);fetch(r.href,s)}};fs();class l extends Array{constructor(e,t){if(super(e),this.sign=t,Object.setPrototypeOf(this,l.prototype),e>l.__kMaxLength)throw new RangeError("Maximum BigInt size exceeded")}static BigInt(e){var t=Math.floor,n=Number.isFinite;if(typeof e=="number"){if(e===0)return l.__zero();if(l.__isOneDigitInt(e))return 0>e?l.__oneDigit(-e,!0):l.__oneDigit(e,!1);if(!n(e)||t(e)!==e)throw new RangeError("The number "+e+" cannot be converted to BigInt because it is not an integer");return l.__fromDouble(e)}if(typeof e=="string"){const r=l.__fromString(e);if(r===null)throw new SyntaxError("Cannot convert "+e+" to a BigInt");return r}if(typeof e=="boolean")return e===!0?l.__oneDigit(1,!1):l.__zero();if(typeof e=="object"){if(e.constructor===l)return e;const r=l.__toPrimitive(e);return l.BigInt(r)}throw new TypeError("Cannot convert "+e+" to a BigInt")}toDebugString(){const e=["BigInt["];for(const t of this)e.push((t&&(t>>>0).toString(16))+", ");return e.push("]"),e.join("")}toString(e=10){if(2>e||36<e)throw new RangeError("toString() radix argument must be between 2 and 36");return this.length===0?"0":(e&e-1)==0?l.__toStringBasePowerOfTwo(this,e):l.__toStringGeneric(this,e,!1)}valueOf(){throw new Error("Convert JSBI instances to native numbers using `toNumber`.")}static toNumber(e){const t=e.length;if(t===0)return 0;if(t===1){const p=e.__unsignedDigit(0);return e.sign?-p:p}const n=e.__digit(t-1),r=l.__clz30(n),s=30*t-r;if(1024<s)return e.sign?-1/0:1/0;let a=s-1,c=n,h=t-1;const d=r+3;let m=d===32?0:c<<d;m>>>=12;const u=d-12;let f=12<=d?0:c<<20+d,y=20+d;for(0<u&&0<h&&(h--,c=e.__digit(h),m|=c>>>30-u,f=c<<u+2,y=u+2);0<y&&0<h;)h--,c=e.__digit(h),f|=30<=y?c<<y-30:c>>>30-y,y-=30;const g=l.__decideRounding(e,y,h,c);if((g===1||g===0&&(1&f)==1)&&(f=f+1>>>0,f===0&&(m++,m>>>20!=0&&(m=0,a++,1023<a))))return e.sign?-1/0:1/0;const w=e.sign?-2147483648:0;return a=a+1023<<20,l.__kBitConversionInts[1]=w|a|m,l.__kBitConversionInts[0]=f,l.__kBitConversionDouble[0]}static unaryMinus(e){if(e.length===0)return e;const t=e.__copy();return t.sign=!e.sign,t}static bitwiseNot(e){return e.sign?l.__absoluteSubOne(e).__trim():l.__absoluteAddOne(e,!0)}static exponentiate(e,t){if(t.sign)throw new RangeError("Exponent must be positive");if(t.length===0)return l.__oneDigit(1,!1);if(e.length===0)return e;if(e.length===1&&e.__digit(0)===1)return e.sign&&(1&t.__digit(0))==0?l.unaryMinus(e):e;if(1<t.length)throw new RangeError("BigInt too big");let n=t.__unsignedDigit(0);if(n===1)return e;if(n>=l.__kMaxLengthBits)throw new RangeError("BigInt too big");if(e.length===1&&e.__digit(0)===2){const a=1+(0|n/30),c=e.sign&&(1&n)!=0,h=new l(a,c);h.__initializeDigits();const d=1<<n%30;return h.__setDigit(a-1,d),h}let r=null,s=e;for((1&n)!=0&&(r=e),n>>=1;n!==0;n>>=1)s=l.multiply(s,s),(1&n)!=0&&(r===null?r=s:r=l.multiply(r,s));return r}static multiply(e,t){if(e.length===0)return e;if(t.length===0)return t;let n=e.length+t.length;30<=e.__clzmsd()+t.__clzmsd()&&n--;const r=new l(n,e.sign!==t.sign);r.__initializeDigits();for(let s=0;s<e.length;s++)l.__multiplyAccumulate(t,e.__digit(s),r,s);return r.__trim()}static divide(e,t){if(t.length===0)throw new RangeError("Division by zero");if(0>l.__absoluteCompare(e,t))return l.__zero();const n=e.sign!==t.sign,r=t.__unsignedDigit(0);let s;if(t.length===1&&32767>=r){if(r===1)return n===e.sign?e:l.unaryMinus(e);s=l.__absoluteDivSmall(e,r,null)}else s=l.__absoluteDivLarge(e,t,!0,!1);return s.sign=n,s.__trim()}static remainder(e,t){if(t.length===0)throw new RangeError("Division by zero");if(0>l.__absoluteCompare(e,t))return e;const n=t.__unsignedDigit(0);if(t.length===1&&32767>=n){if(n===1)return l.__zero();const s=l.__absoluteModSmall(e,n);return s===0?l.__zero():l.__oneDigit(s,e.sign)}const r=l.__absoluteDivLarge(e,t,!1,!0);return r.sign=e.sign,r.__trim()}static add(e,t){const n=e.sign;return n===t.sign?l.__absoluteAdd(e,t,n):0<=l.__absoluteCompare(e,t)?l.__absoluteSub(e,t,n):l.__absoluteSub(t,e,!n)}static subtract(e,t){const n=e.sign;return n===t.sign?0<=l.__absoluteCompare(e,t)?l.__absoluteSub(e,t,n):l.__absoluteSub(t,e,!n):l.__absoluteAdd(e,t,n)}static leftShift(e,t){return t.length===0||e.length===0?e:t.sign?l.__rightShiftByAbsolute(e,t):l.__leftShiftByAbsolute(e,t)}static signedRightShift(e,t){return t.length===0||e.length===0?e:t.sign?l.__leftShiftByAbsolute(e,t):l.__rightShiftByAbsolute(e,t)}static unsignedRightShift(){throw new TypeError("BigInts have no unsigned right shift; use >> instead")}static lessThan(e,t){return 0>l.__compareToBigInt(e,t)}static lessThanOrEqual(e,t){return 0>=l.__compareToBigInt(e,t)}static greaterThan(e,t){return 0<l.__compareToBigInt(e,t)}static greaterThanOrEqual(e,t){return 0<=l.__compareToBigInt(e,t)}static equal(e,t){if(e.sign!==t.sign||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e.__digit(n)!==t.__digit(n))return!1;return!0}static notEqual(e,t){return!l.equal(e,t)}static bitwiseAnd(e,t){var n=Math.max;if(!e.sign&&!t.sign)return l.__absoluteAnd(e,t).__trim();if(e.sign&&t.sign){const r=n(e.length,t.length)+1;let s=l.__absoluteSubOne(e,r);const a=l.__absoluteSubOne(t);return s=l.__absoluteOr(s,a,s),l.__absoluteAddOne(s,!0,s).__trim()}return e.sign&&([e,t]=[t,e]),l.__absoluteAndNot(e,l.__absoluteSubOne(t)).__trim()}static bitwiseXor(e,t){var n=Math.max;if(!e.sign&&!t.sign)return l.__absoluteXor(e,t).__trim();if(e.sign&&t.sign){const a=n(e.length,t.length),c=l.__absoluteSubOne(e,a),h=l.__absoluteSubOne(t);return l.__absoluteXor(c,h,c).__trim()}const r=n(e.length,t.length)+1;e.sign&&([e,t]=[t,e]);let s=l.__absoluteSubOne(t,r);return s=l.__absoluteXor(s,e,s),l.__absoluteAddOne(s,!0,s).__trim()}static bitwiseOr(e,t){var n=Math.max;const r=n(e.length,t.length);if(!e.sign&&!t.sign)return l.__absoluteOr(e,t).__trim();if(e.sign&&t.sign){let a=l.__absoluteSubOne(e,r);const c=l.__absoluteSubOne(t);return a=l.__absoluteAnd(a,c,a),l.__absoluteAddOne(a,!0,a).__trim()}e.sign&&([e,t]=[t,e]);let s=l.__absoluteSubOne(t,r);return s=l.__absoluteAndNot(s,e,s),l.__absoluteAddOne(s,!0,s).__trim()}static asIntN(e,t){var n=Math.floor;if(t.length===0)return t;if(e=n(e),0>e)throw new RangeError("Invalid value: not (convertible to) a safe integer");if(e===0)return l.__zero();if(e>=l.__kMaxLengthBits)return t;const r=0|(e+29)/30;if(t.length<r)return t;const s=t.__unsignedDigit(r-1),a=1<<(e-1)%30;if(t.length===r&&s<a)return t;if((s&a)!==a)return l.__truncateToNBits(e,t);if(!t.sign)return l.__truncateAndSubFromPowerOfTwo(e,t,!0);if((s&a-1)==0){for(let c=r-2;0<=c;c--)if(t.__digit(c)!==0)return l.__truncateAndSubFromPowerOfTwo(e,t,!1);return t.length===r&&s===a?t:l.__truncateToNBits(e,t)}return l.__truncateAndSubFromPowerOfTwo(e,t,!1)}static asUintN(e,t){var n=Math.floor;if(t.length===0)return t;if(e=n(e),0>e)throw new RangeError("Invalid value: not (convertible to) a safe integer");if(e===0)return l.__zero();if(t.sign){if(e>l.__kMaxLengthBits)throw new RangeError("BigInt too big");return l.__truncateAndSubFromPowerOfTwo(e,t,!1)}if(e>=l.__kMaxLengthBits)return t;const r=0|(e+29)/30;if(t.length<r)return t;const s=e%30;return t.length==r&&(s===0||t.__digit(r-1)>>>s==0)?t:l.__truncateToNBits(e,t)}static ADD(e,t){if(e=l.__toPrimitive(e),t=l.__toPrimitive(t),typeof e=="string")return typeof t!="string"&&(t=t.toString()),e+t;if(typeof t=="string")return e.toString()+t;if(e=l.__toNumeric(e),t=l.__toNumeric(t),l.__isBigInt(e)&&l.__isBigInt(t))return l.add(e,t);if(typeof e=="number"&&typeof t=="number")return e+t;throw new TypeError("Cannot mix BigInt and other types, use explicit conversions")}static LT(e,t){return l.__compare(e,t,0)}static LE(e,t){return l.__compare(e,t,1)}static GT(e,t){return l.__compare(e,t,2)}static GE(e,t){return l.__compare(e,t,3)}static EQ(e,t){for(;;){if(l.__isBigInt(e))return l.__isBigInt(t)?l.equal(e,t):l.EQ(t,e);if(typeof e=="number"){if(l.__isBigInt(t))return l.__equalToNumber(t,e);if(typeof t!="object")return e==t;t=l.__toPrimitive(t)}else if(typeof e=="string"){if(l.__isBigInt(t))return e=l.__fromString(e),e!==null&&l.equal(e,t);if(typeof t!="object")return e==t;t=l.__toPrimitive(t)}else if(typeof e=="boolean"){if(l.__isBigInt(t))return l.__equalToNumber(t,+e);if(typeof t!="object")return e==t;t=l.__toPrimitive(t)}else if(typeof e=="symbol"){if(l.__isBigInt(t))return!1;if(typeof t!="object")return e==t;t=l.__toPrimitive(t)}else if(typeof e=="object"){if(typeof t=="object"&&t.constructor!==l)return e==t;e=l.__toPrimitive(e)}else return e==t}}static NE(e,t){return!l.EQ(e,t)}static DataViewGetBigInt64(e,t,n=!1){return l.asIntN(64,l.DataViewGetBigUint64(e,t,n))}static DataViewGetBigUint64(e,t,n=!1){const[r,s]=n?[4,0]:[0,4],a=e.getUint32(t+r,n),c=e.getUint32(t+s,n),h=new l(3,!1);return h.__setDigit(0,1073741823&c),h.__setDigit(1,(268435455&a)<<2|c>>>30),h.__setDigit(2,a>>>28),h.__trim()}static DataViewSetBigInt64(e,t,n,r=!1){l.DataViewSetBigUint64(e,t,n,r)}static DataViewSetBigUint64(e,t,n,r=!1){n=l.asUintN(64,n);let s=0,a=0;if(0<n.length&&(a=n.__digit(0),1<n.length)){const d=n.__digit(1);a|=d<<30,s=d>>>2,2<n.length&&(s|=n.__digit(2)<<28)}const[c,h]=r?[4,0]:[0,4];e.setUint32(t+c,s,r),e.setUint32(t+h,a,r)}static __zero(){return new l(0,!1)}static __oneDigit(e,t){const n=new l(1,t);return n.__setDigit(0,e),n}__copy(){const e=new l(this.length,this.sign);for(let t=0;t<this.length;t++)e[t]=this[t];return e}__trim(){let e=this.length,t=this[e-1];for(;t===0;)e--,t=this[e-1],this.pop();return e===0&&(this.sign=!1),this}__initializeDigits(){for(let e=0;e<this.length;e++)this[e]=0}static __decideRounding(e,t,n,r){if(0<t)return-1;let s;if(0>t)s=-t-1;else{if(n===0)return-1;n--,r=e.__digit(n),s=29}let a=1<<s;if((r&a)==0)return-1;if(a-=1,(r&a)!=0)return 1;for(;0<n;)if(n--,e.__digit(n)!==0)return 1;return 0}static __fromDouble(e){l.__kBitConversionDouble[0]=e;const t=2047&l.__kBitConversionInts[1]>>>20,n=t-1023,r=(0|n/30)+1,s=new l(r,0>e);let a=1048575&l.__kBitConversionInts[1]|1048576,c=l.__kBitConversionInts[0];const h=20,d=n%30;let m,u=0;if(d<20){const f=h-d;u=f+32,m=a>>>f,a=a<<32-f|c>>>f,c<<=32-f}else if(d===20)u=32,m=a,a=c,c=0;else{const f=d-h;u=32-f,m=a<<f|c>>>32-f,a=c<<f,c=0}s.__setDigit(r-1,m);for(let f=r-2;0<=f;f--)0<u?(u-=30,m=a>>>2,a=a<<30|c>>>2,c<<=30):m=0,s.__setDigit(f,m);return s.__trim()}static __isWhitespace(e){return 13>=e&&9<=e||(159>=e?e==32:131071>=e?e==160||e==5760:196607>=e?(e&=131071,10>=e||e==40||e==41||e==47||e==95||e==4096):e==65279)}static __fromString(e,t=0){let n=0;const r=e.length;let s=0;if(s===r)return l.__zero();let a=e.charCodeAt(s);for(;l.__isWhitespace(a);){if(++s===r)return l.__zero();a=e.charCodeAt(s)}if(a===43){if(++s===r)return null;a=e.charCodeAt(s),n=1}else if(a===45){if(++s===r)return null;a=e.charCodeAt(s),n=-1}if(t===0){if(t=10,a===48){if(++s===r)return l.__zero();if(a=e.charCodeAt(s),a===88||a===120){if(t=16,++s===r)return null;a=e.charCodeAt(s)}else if(a===79||a===111){if(t=8,++s===r)return null;a=e.charCodeAt(s)}else if(a===66||a===98){if(t=2,++s===r)return null;a=e.charCodeAt(s)}}}else if(t===16&&a===48){if(++s===r)return l.__zero();if(a=e.charCodeAt(s),a===88||a===120){if(++s===r)return null;a=e.charCodeAt(s)}}if(n!=0&&t!==10)return null;for(;a===48;){if(++s===r)return l.__zero();a=e.charCodeAt(s)}const c=r-s;let h=l.__kMaxBitsPerChar[t],d=l.__kBitsPerCharTableMultiplier-1;if(c>1073741824/h)return null;const m=h*c+d>>>l.__kBitsPerCharTableShift,u=new l(0|(m+29)/30,!1),f=10>t?t:10,y=10<t?t-10:0;if((t&t-1)==0){h>>=l.__kBitsPerCharTableShift;const g=[],w=[];let p=!1;do{let v=0,T=0;for(;;){let b;if(a-48>>>0<f)b=a-48;else if((32|a)-97>>>0<y)b=(32|a)-87;else{p=!0;break}if(T+=h,v=v<<h|b,++s===r){p=!0;break}if(a=e.charCodeAt(s),30<T+h)break}g.push(v),w.push(T)}while(!p);l.__fillFromParts(u,g,w)}else{u.__initializeDigits();let g=!1,w=0;do{let p=0,v=1;for(;;){let b;if(a-48>>>0<f)b=a-48;else if((32|a)-97>>>0<y)b=(32|a)-87;else{g=!0;break}const D=v*t;if(1073741823<D)break;if(v=D,p=p*t+b,w++,++s===r){g=!0;break}a=e.charCodeAt(s)}d=30*l.__kBitsPerCharTableMultiplier-1;const T=0|(h*w+d>>>l.__kBitsPerCharTableShift)/30;u.__inplaceMultiplyAdd(v,p,T)}while(!g)}if(s!==r){if(!l.__isWhitespace(a))return null;for(s++;s<r;s++)if(a=e.charCodeAt(s),!l.__isWhitespace(a))return null}return u.sign=n==-1,u.__trim()}static __fillFromParts(e,t,n){let r=0,s=0,a=0;for(let c=t.length-1;0<=c;c--){const h=t[c],d=n[c];s|=h<<a,a+=d,a===30?(e.__setDigit(r++,s),a=0,s=0):30<a&&(e.__setDigit(r++,1073741823&s),a-=30,s=h>>>d-a)}if(s!==0){if(r>=e.length)throw new Error("implementation bug");e.__setDigit(r++,s)}for(;r<e.length;r++)e.__setDigit(r,0)}static __toStringBasePowerOfTwo(e,t){const n=e.length;let r=t-1;r=(85&r>>>1)+(85&r),r=(51&r>>>2)+(51&r),r=(15&r>>>4)+(15&r);const s=r,a=t-1,c=e.__digit(n-1),h=l.__clz30(c);let d=0|(30*n-h+s-1)/s;if(e.sign&&d++,268435456<d)throw new Error("string too long");const m=Array(d);let u=d-1,f=0,y=0;for(let w=0;w<n-1;w++){const p=e.__digit(w),v=(f|p<<y)&a;m[u--]=l.__kConversionChars[v];const T=s-y;for(f=p>>>T,y=30-T;y>=s;)m[u--]=l.__kConversionChars[f&a],f>>>=s,y-=s}const g=(f|c<<y)&a;for(m[u--]=l.__kConversionChars[g],f=c>>>s-y;f!==0;)m[u--]=l.__kConversionChars[f&a],f>>>=s;if(e.sign&&(m[u--]="-"),u!=-1)throw new Error("implementation bug");return m.join("")}static __toStringGeneric(e,t,n){const r=e.length;if(r===0)return"";if(r===1){let w=e.__unsignedDigit(0).toString(t);return n===!1&&e.sign&&(w="-"+w),w}const s=30*r-l.__clz30(e.__digit(r-1)),a=l.__kMaxBitsPerChar[t],c=a-1;let h=s*l.__kBitsPerCharTableMultiplier;h+=c-1,h=0|h/c;const d=h+1>>1,m=l.exponentiate(l.__oneDigit(t,!1),l.__oneDigit(d,!1));let u,f;const y=m.__unsignedDigit(0);if(m.length===1&&32767>=y){u=new l(e.length,!1),u.__initializeDigits();let w=0;for(let p=2*e.length-1;0<=p;p--){const v=w<<15|e.__halfDigit(p);u.__setHalfDigit(p,0|v/y),w=0|v%y}f=w.toString(t)}else{const w=l.__absoluteDivLarge(e,m,!0,!0);u=w.quotient;const p=w.remainder.__trim();f=l.__toStringGeneric(p,t,!0)}u.__trim();let g=l.__toStringGeneric(u,t,!0);for(;f.length<d;)f="0"+f;return n===!1&&e.sign&&(g="-"+g),g+f}static __unequalSign(e){return e?-1:1}static __absoluteGreater(e){return e?-1:1}static __absoluteLess(e){return e?1:-1}static __compareToBigInt(e,t){const n=e.sign;if(n!==t.sign)return l.__unequalSign(n);const r=l.__absoluteCompare(e,t);return 0<r?l.__absoluteGreater(n):0>r?l.__absoluteLess(n):0}static __compareToNumber(e,t){if(l.__isOneDigitInt(t)){const n=e.sign,r=0>t;if(n!==r)return l.__unequalSign(n);if(e.length===0){if(r)throw new Error("implementation bug");return t===0?0:-1}if(1<e.length)return l.__absoluteGreater(n);const s=Math.abs(t),a=e.__unsignedDigit(0);return a>s?l.__absoluteGreater(n):a<s?l.__absoluteLess(n):0}return l.__compareToDouble(e,t)}static __compareToDouble(e,t){if(t!==t)return t;if(t===1/0)return-1;if(t===-1/0)return 1;const n=e.sign;if(n!==0>t)return l.__unequalSign(n);if(t===0)throw new Error("implementation bug: should be handled elsewhere");if(e.length===0)return-1;l.__kBitConversionDouble[0]=t;const r=2047&l.__kBitConversionInts[1]>>>20;if(r==2047)throw new Error("implementation bug: handled elsewhere");const s=r-1023;if(0>s)return l.__absoluteGreater(n);const a=e.length;let c=e.__digit(a-1);const h=l.__clz30(c),d=30*a-h,m=s+1;if(d<m)return l.__absoluteLess(n);if(d>m)return l.__absoluteGreater(n);let u=1048576|1048575&l.__kBitConversionInts[1],f=l.__kBitConversionInts[0];const y=20,g=29-h;if(g!==(0|(d-1)%30))throw new Error("implementation bug");let w,p=0;if(20>g){const v=y-g;p=v+32,w=u>>>v,u=u<<32-v|f>>>v,f<<=32-v}else if(g===20)p=32,w=u,u=f,f=0;else{const v=g-y;p=32-v,w=u<<v|f>>>32-v,u=f<<v,f=0}if(c>>>=0,w>>>=0,c>w)return l.__absoluteGreater(n);if(c<w)return l.__absoluteLess(n);for(let v=a-2;0<=v;v--){0<p?(p-=30,w=u>>>2,u=u<<30|f>>>2,f<<=30):w=0;const T=e.__unsignedDigit(v);if(T>w)return l.__absoluteGreater(n);if(T<w)return l.__absoluteLess(n)}if(u!==0||f!==0){if(p===0)throw new Error("implementation bug");return l.__absoluteLess(n)}return 0}static __equalToNumber(e,t){var n=Math.abs;return l.__isOneDigitInt(t)?t===0?e.length===0:e.length===1&&e.sign===0>t&&e.__unsignedDigit(0)===n(t):l.__compareToDouble(e,t)===0}static __comparisonResultToBool(e,t){return t===0?0>e:t===1?0>=e:t===2?0<e:t===3?0<=e:void 0}static __compare(e,t,n){if(e=l.__toPrimitive(e),t=l.__toPrimitive(t),typeof e=="string"&&typeof t=="string")switch(n){case 0:return e<t;case 1:return e<=t;case 2:return e>t;case 3:return e>=t}if(l.__isBigInt(e)&&typeof t=="string")return t=l.__fromString(t),t!==null&&l.__comparisonResultToBool(l.__compareToBigInt(e,t),n);if(typeof e=="string"&&l.__isBigInt(t))return e=l.__fromString(e),e!==null&&l.__comparisonResultToBool(l.__compareToBigInt(e,t),n);if(e=l.__toNumeric(e),t=l.__toNumeric(t),l.__isBigInt(e)){if(l.__isBigInt(t))return l.__comparisonResultToBool(l.__compareToBigInt(e,t),n);if(typeof t!="number")throw new Error("implementation bug");return l.__comparisonResultToBool(l.__compareToNumber(e,t),n)}if(typeof e!="number")throw new Error("implementation bug");if(l.__isBigInt(t))return l.__comparisonResultToBool(l.__compareToNumber(t,e),2^n);if(typeof t!="number")throw new Error("implementation bug");return n===0?e<t:n===1?e<=t:n===2?e>t:n===3?e>=t:void 0}__clzmsd(){return l.__clz30(this.__digit(this.length-1))}static __absoluteAdd(e,t,n){if(e.length<t.length)return l.__absoluteAdd(t,e,n);if(e.length===0)return e;if(t.length===0)return e.sign===n?e:l.unaryMinus(e);let r=e.length;(e.__clzmsd()===0||t.length===e.length&&t.__clzmsd()===0)&&r++;const s=new l(r,n);let a=0,c=0;for(;c<t.length;c++){const h=e.__digit(c)+t.__digit(c)+a;a=h>>>30,s.__setDigit(c,1073741823&h)}for(;c<e.length;c++){const h=e.__digit(c)+a;a=h>>>30,s.__setDigit(c,1073741823&h)}return c<s.length&&s.__setDigit(c,a),s.__trim()}static __absoluteSub(e,t,n){if(e.length===0)return e;if(t.length===0)return e.sign===n?e:l.unaryMinus(e);const r=new l(e.length,n);let s=0,a=0;for(;a<t.length;a++){const c=e.__digit(a)-t.__digit(a)-s;s=1&c>>>30,r.__setDigit(a,1073741823&c)}for(;a<e.length;a++){const c=e.__digit(a)-s;s=1&c>>>30,r.__setDigit(a,1073741823&c)}return r.__trim()}static __absoluteAddOne(e,t,n=null){const r=e.length;n===null?n=new l(r,t):n.sign=t;let s=1;for(let a=0;a<r;a++){const c=e.__digit(a)+s;s=c>>>30,n.__setDigit(a,1073741823&c)}return s!=0&&n.__setDigitGrow(r,1),n}static __absoluteSubOne(e,t){const n=e.length;t=t||n;const r=new l(t,!1);let s=1;for(let a=0;a<n;a++){const c=e.__digit(a)-s;s=1&c>>>30,r.__setDigit(a,1073741823&c)}if(s!=0)throw new Error("implementation bug");for(let a=n;a<t;a++)r.__setDigit(a,0);return r}static __absoluteAnd(e,t,n=null){let r=e.length,s=t.length,a=s;if(r<s){a=r;const d=e,m=r;e=t,r=s,t=d,s=m}let c=a;n===null?n=new l(c,!1):c=n.length;let h=0;for(;h<a;h++)n.__setDigit(h,e.__digit(h)&t.__digit(h));for(;h<c;h++)n.__setDigit(h,0);return n}static __absoluteAndNot(e,t,n=null){const r=e.length,s=t.length;let a=s;r<s&&(a=r);let c=r;n===null?n=new l(c,!1):c=n.length;let h=0;for(;h<a;h++)n.__setDigit(h,e.__digit(h)&~t.__digit(h));for(;h<r;h++)n.__setDigit(h,e.__digit(h));for(;h<c;h++)n.__setDigit(h,0);return n}static __absoluteOr(e,t,n=null){let r=e.length,s=t.length,a=s;if(r<s){a=r;const d=e,m=r;e=t,r=s,t=d,s=m}let c=r;n===null?n=new l(c,!1):c=n.length;let h=0;for(;h<a;h++)n.__setDigit(h,e.__digit(h)|t.__digit(h));for(;h<r;h++)n.__setDigit(h,e.__digit(h));for(;h<c;h++)n.__setDigit(h,0);return n}static __absoluteXor(e,t,n=null){let r=e.length,s=t.length,a=s;if(r<s){a=r;const d=e,m=r;e=t,r=s,t=d,s=m}let c=r;n===null?n=new l(c,!1):c=n.length;let h=0;for(;h<a;h++)n.__setDigit(h,e.__digit(h)^t.__digit(h));for(;h<r;h++)n.__setDigit(h,e.__digit(h));for(;h<c;h++)n.__setDigit(h,0);return n}static __absoluteCompare(e,t){const n=e.length-t.length;if(n!=0)return n;let r=e.length-1;for(;0<=r&&e.__digit(r)===t.__digit(r);)r--;return 0>r?0:e.__unsignedDigit(r)>t.__unsignedDigit(r)?1:-1}static __multiplyAccumulate(e,t,n,r){if(t===0)return;const s=32767&t,a=t>>>15;let c=0,h=0;for(let d,m=0;m<e.length;m++,r++){d=n.__digit(r);const u=e.__digit(m),f=32767&u,y=u>>>15,g=l.__imul(f,s),w=l.__imul(f,a),p=l.__imul(y,s),v=l.__imul(y,a);d+=h+g+c,c=d>>>30,d&=1073741823,d+=((32767&w)<<15)+((32767&p)<<15),c+=d>>>30,h=v+(w>>>15)+(p>>>15),n.__setDigit(r,1073741823&d)}for(;c!=0||h!==0;r++){let d=n.__digit(r);d+=c+h,h=0,c=d>>>30,n.__setDigit(r,1073741823&d)}}static __internalMultiplyAdd(e,t,n,r,s){let a=n,c=0;for(let h=0;h<r;h++){const d=e.__digit(h),m=l.__imul(32767&d,t),u=l.__imul(d>>>15,t),f=m+((32767&u)<<15)+c+a;a=f>>>30,c=u>>>15,s.__setDigit(h,1073741823&f)}if(s.length>r)for(s.__setDigit(r++,a+c);r<s.length;)s.__setDigit(r++,0);else if(a+c!==0)throw new Error("implementation bug")}__inplaceMultiplyAdd(e,t,n){n>this.length&&(n=this.length);const r=32767&e,s=e>>>15;let a=0,c=t;for(let h=0;h<n;h++){const d=this.__digit(h),m=32767&d,u=d>>>15,f=l.__imul(m,r),y=l.__imul(m,s),g=l.__imul(u,r),w=l.__imul(u,s);let p=c+f+a;a=p>>>30,p&=1073741823,p+=((32767&y)<<15)+((32767&g)<<15),a+=p>>>30,c=w+(y>>>15)+(g>>>15),this.__setDigit(h,1073741823&p)}if(a!=0||c!==0)throw new Error("implementation bug")}static __absoluteDivSmall(e,t,n=null){n===null&&(n=new l(e.length,!1));let r=0;for(let s,a=2*e.length-1;0<=a;a-=2){s=(r<<15|e.__halfDigit(a))>>>0;const c=0|s/t;r=0|s%t,s=(r<<15|e.__halfDigit(a-1))>>>0;const h=0|s/t;r=0|s%t,n.__setDigit(a>>>1,c<<15|h)}return n}static __absoluteModSmall(e,t){let n=0;for(let r=2*e.length-1;0<=r;r--){const s=(n<<15|e.__halfDigit(r))>>>0;n=0|s%t}return n}static __absoluteDivLarge(e,t,n,r){const s=t.__halfDigitLength(),a=t.length,c=e.__halfDigitLength()-s;let h=null;n&&(h=new l(c+2>>>1,!1),h.__initializeDigits());const d=new l(s+2>>>1,!1);d.__initializeDigits();const m=l.__clz15(t.__halfDigit(s-1));0<m&&(t=l.__specialLeftShift(t,m,0));const u=l.__specialLeftShift(e,m,1),f=t.__halfDigit(s-1);let y=0;for(let g,w=c;0<=w;w--){g=32767;const p=u.__halfDigit(w+s);if(p!==f){const T=(p<<15|u.__halfDigit(w+s-1))>>>0;g=0|T/f;let b=0|T%f;const D=t.__halfDigit(s-2),_=u.__halfDigit(w+s-2);for(;l.__imul(g,D)>>>0>(b<<16|_)>>>0&&(g--,b+=f,!(32767<b)););}l.__internalMultiplyAdd(t,g,0,a,d);let v=u.__inplaceSub(d,w,s+1);v!==0&&(v=u.__inplaceAdd(t,w,s),u.__setHalfDigit(w+s,32767&u.__halfDigit(w+s)+v),g--),n&&(1&w?y=g<<15:h.__setDigit(w>>>1,y|g))}if(r)return u.__inplaceRightShift(m),n?{quotient:h,remainder:u}:u;if(n)return h;throw new Error("unreachable")}static __clz15(e){return l.__clz30(e)-15}__inplaceAdd(e,t,n){let r=0;for(let s=0;s<n;s++){const a=this.__halfDigit(t+s)+e.__halfDigit(s)+r;r=a>>>15,this.__setHalfDigit(t+s,32767&a)}return r}__inplaceSub(e,t,n){let r=0;if(1&t){t>>=1;let s=this.__digit(t),a=32767&s,c=0;for(;c<n-1>>>1;c++){const m=e.__digit(c),u=(s>>>15)-(32767&m)-r;r=1&u>>>15,this.__setDigit(t+c,(32767&u)<<15|32767&a),s=this.__digit(t+c+1),a=(32767&s)-(m>>>15)-r,r=1&a>>>15}const h=e.__digit(c),d=(s>>>15)-(32767&h)-r;if(r=1&d>>>15,this.__setDigit(t+c,(32767&d)<<15|32767&a),t+c+1>=this.length)throw new RangeError("out of bounds");(1&n)==0&&(s=this.__digit(t+c+1),a=(32767&s)-(h>>>15)-r,r=1&a>>>15,this.__setDigit(t+e.length,1073709056&s|32767&a))}else{t>>=1;let s=0;for(;s<e.length-1;s++){const m=this.__digit(t+s),u=e.__digit(s),f=(32767&m)-(32767&u)-r;r=1&f>>>15;const y=(m>>>15)-(u>>>15)-r;r=1&y>>>15,this.__setDigit(t+s,(32767&y)<<15|32767&f)}const a=this.__digit(t+s),c=e.__digit(s),h=(32767&a)-(32767&c)-r;r=1&h>>>15;let d=0;(1&n)==0&&(d=(a>>>15)-(c>>>15)-r,r=1&d>>>15),this.__setDigit(t+s,(32767&d)<<15|32767&h)}return r}__inplaceRightShift(e){if(e===0)return;let t=this.__digit(0)>>>e;const n=this.length-1;for(let r=0;r<n;r++){const s=this.__digit(r+1);this.__setDigit(r,1073741823&s<<30-e|t),t=s>>>e}this.__setDigit(n,t)}static __specialLeftShift(e,t,n){const r=e.length,s=new l(r+n,!1);if(t===0){for(let c=0;c<r;c++)s.__setDigit(c,e.__digit(c));return 0<n&&s.__setDigit(r,0),s}let a=0;for(let c=0;c<r;c++){const h=e.__digit(c);s.__setDigit(c,1073741823&h<<t|a),a=h>>>30-t}return 0<n&&s.__setDigit(r,a),s}static __leftShiftByAbsolute(e,t){const n=l.__toShiftAmount(t);if(0>n)throw new RangeError("BigInt too big");const r=0|n/30,s=n%30,a=e.length,c=s!==0&&e.__digit(a-1)>>>30-s!=0,h=a+r+(c?1:0),d=new l(h,e.sign);if(s===0){let m=0;for(;m<r;m++)d.__setDigit(m,0);for(;m<h;m++)d.__setDigit(m,e.__digit(m-r))}else{let m=0;for(let u=0;u<r;u++)d.__setDigit(u,0);for(let u=0;u<a;u++){const f=e.__digit(u);d.__setDigit(u+r,1073741823&f<<s|m),m=f>>>30-s}if(c)d.__setDigit(a+r,m);else if(m!==0)throw new Error("implementation bug")}return d.__trim()}static __rightShiftByAbsolute(e,t){const n=e.length,r=e.sign,s=l.__toShiftAmount(t);if(0>s)return l.__rightShiftByMaximum(r);const a=0|s/30,c=s%30;let h=n-a;if(0>=h)return l.__rightShiftByMaximum(r);let d=!1;if(r){if((e.__digit(a)&(1<<c)-1)!=0)d=!0;else for(let u=0;u<a;u++)if(e.__digit(u)!==0){d=!0;break}}d&&c===0&&~e.__digit(n-1)==0&&h++;let m=new l(h,r);if(c===0){m.__setDigit(h-1,0);for(let u=a;u<n;u++)m.__setDigit(u-a,e.__digit(u))}else{let u=e.__digit(a)>>>c;const f=n-a-1;for(let y=0;y<f;y++){const g=e.__digit(y+a+1);m.__setDigit(y,1073741823&g<<30-c|u),u=g>>>c}m.__setDigit(f,u)}return d&&(m=l.__absoluteAddOne(m,!0,m)),m.__trim()}static __rightShiftByMaximum(e){return e?l.__oneDigit(1,!0):l.__zero()}static __toShiftAmount(e){if(1<e.length)return-1;const t=e.__unsignedDigit(0);return t>l.__kMaxLengthBits?-1:t}static __toPrimitive(e,t="default"){if(typeof e!="object"||e.constructor===l)return e;if(typeof Symbol!="undefined"&&typeof Symbol.toPrimitive=="symbol"){const s=e[Symbol.toPrimitive];if(s){const a=s(t);if(typeof a!="object")return a;throw new TypeError("Cannot convert object to primitive value")}}const n=e.valueOf;if(n){const s=n.call(e);if(typeof s!="object")return s}const r=e.toString;if(r){const s=r.call(e);if(typeof s!="object")return s}throw new TypeError("Cannot convert object to primitive value")}static __toNumeric(e){return l.__isBigInt(e)?e:+e}static __isBigInt(e){return typeof e=="object"&&e!==null&&e.constructor===l}static __truncateToNBits(e,t){const n=0|(e+29)/30,r=new l(n,t.sign),s=n-1;for(let c=0;c<s;c++)r.__setDigit(c,t.__digit(c));let a=t.__digit(s);if(e%30!=0){const c=32-e%30;a=a<<c>>>c}return r.__setDigit(s,a),r.__trim()}static __truncateAndSubFromPowerOfTwo(e,t,n){var r=Math.min;const s=0|(e+29)/30,a=new l(s,n);let c=0;const h=s-1;let d=0;for(const y=r(h,t.length);c<y;c++){const g=0-t.__digit(c)-d;d=1&g>>>30,a.__setDigit(c,1073741823&g)}for(;c<h;c++)a.__setDigit(c,0|1073741823&-d);let m=h<t.length?t.__digit(h):0;const u=e%30;let f;if(u==0)f=0-m-d,f&=1073741823;else{const y=32-u;m=m<<y>>>y;const g=1<<32-y;f=g-m-d,f&=g-1}return a.__setDigit(h,f),a.__trim()}__digit(e){return this[e]}__unsignedDigit(e){return this[e]>>>0}__setDigit(e,t){this[e]=0|t}__setDigitGrow(e,t){this[e]=0|t}__halfDigitLength(){const e=this.length;return 32767>=this.__unsignedDigit(e-1)?2*e-1:2*e}__halfDigit(e){return 32767&this[e>>>1]>>>15*(1&e)}__setHalfDigit(e,t){const n=e>>>1,r=this.__digit(n),s=1&e?32767&r|t<<15:1073709056&r|32767&t;this.__setDigit(n,s)}static __digitPow(e,t){let n=1;for(;0<t;)1&t&&(n*=e),t>>>=1,e*=e;return n}static __isOneDigitInt(e){return(1073741823&e)===e}}l.__kMaxLength=33554432,l.__kMaxLengthBits=l.__kMaxLength<<5,l.__kMaxBitsPerChar=[0,0,32,51,64,75,83,90,96,102,107,111,115,119,122,126,128,131,134,136,139,141,143,145,147,149,151,153,154,156,158,159,160,162,163,165,166],l.__kBitsPerCharTableShift=5,l.__kBitsPerCharTableMultiplier=1<<l.__kBitsPerCharTableShift,l.__kConversionChars=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"],l.__kBitConversionBuffer=new ArrayBuffer(8),l.__kBitConversionDouble=new Float64Array(l.__kBitConversionBuffer),l.__kBitConversionInts=new Int32Array(l.__kBitConversionBuffer),l.__clz30=Math.clz32?function(i){return Math.clz32(i)-2}:function(i){return i===0?30:0|29-(0|Math.log(i>>>0)/Math.LN2)},l.__imul=Math.imul||function(i,e){return 0|i*e};const Kr={};function kt(i,e){Object.defineProperty(i.prototype,Symbol.toStringTag,{value:e,writable:!1,enumerable:!1,configurable:!0});for(const t of Object.getOwnPropertyNames(i)){const n=Object.getOwnPropertyDescriptor(i,t);n.configurable&&n.enumerable&&(n.enumerable=!1,Object.defineProperty(i,t,n))}for(const t of Object.getOwnPropertyNames(i.prototype)){const n=Object.getOwnPropertyDescriptor(i.prototype,t);n.configurable&&n.enumerable&&(n.enumerable=!1,Object.defineProperty(i.prototype,t,n))}Jr(e,i),Jr(`${e}.prototype`,i.prototype)}function Jr(i,e){const t=`%${i}%`;if(Kr[t]!==void 0)throw new Error(`intrinsic ${i} already exists`);Kr[t]=e}function F(i){return Kr[i]}const P="slot-epochNanoSeconds",At="slot-timezone-identifier",R="slot-year",$="slot-month",I="slot-day",Z="slot-hour",j="slot-minute",A="slot-second",S="slot-millisecond",q="slot-microsecond",U="slot-nanosecond",E="slot-calendar",je="slot-cached-instant",J="slot-time-zone",Se="slot-years",Oe="slot-months",Ke="slot-weeks",qe="slot-days",Ue="slot-hours",ze="slot-minutes",Ge="slot-seconds",We="slot-milliseconds",He="slot-microseconds",Ve="slot-nanoseconds",Ee="slot-calendar-identifier",ui=new WeakMap;function It(i){ui.set(i,Object.create(null))}function yo(i){return ui.get(i)}function ke(i,...e){if(!i||typeof i!="object")return!1;const t=yo(i);return!!t&&e.reduce((n,r)=>n&&r in t,!0)}function o(i,e){const t=yo(i)[e];if(t===void 0)throw new TypeError(`Missing internal slot ${e}`);return t}function H(i,e,t){yo(i)[e]=t}const Fn=Array.prototype.includes,ys=Array.prototype.push,gs=globalThis.Intl.DateTimeFormat,ws=Array.prototype.sort,ps=Math.abs,vs=Math.floor,eo=Object.entries,Vo=Object.keys,me={};class fr{constructor(e){if(arguments.length<1)throw new RangeError("missing argument: id is required");const t=x(e);if(!wi(t))throw new RangeError(`invalid calendar identifier ${t}`);It(this),H(this,Ee,t)}get id(){if(!Te(this))throw new TypeError("invalid receiver");return x(this)}dateFromFields(e,t){if(!Te(this))throw new TypeError("invalid receiver");if(!he(e))throw new TypeError("invalid fields");const n=z(t);return me[o(this,Ee)].dateFromFields(e,n,this)}yearMonthFromFields(e,t){if(!Te(this))throw new TypeError("invalid receiver");if(!he(e))throw new TypeError("invalid fields");const n=z(t);return me[o(this,Ee)].yearMonthFromFields(e,n,this)}monthDayFromFields(e,t){if(!Te(this))throw new TypeError("invalid receiver");if(!he(e))throw new TypeError("invalid fields");const n=z(t);return me[o(this,Ee)].monthDayFromFields(e,n,this)}fields(e){if(!Te(this))throw new TypeError("invalid receiver");const t=[],n=new Set(["year","month","monthCode","day","hour","minute","second","millisecond","microsecond","nanosecond"]);for(const r of e){if(typeof r!="string")throw new TypeError("invalid fields");if(!n.has(r))throw new RangeError(`invalid field name ${r}`);n.delete(r),ys.call(t,r)}return me[o(this,Ee)].fields(t)}mergeFields(e,t){if(!Te(this))throw new TypeError("invalid receiver");return me[o(this,Ee)].mergeFields(e,t)}dateAdd(e,t,n){if(!Te(this))throw new TypeError("invalid receiver");const r=ae(e),s=fn(t),a=Le(z(n)),{days:c}=xe(o(s,qe),o(s,Ue),o(s,ze),o(s,Ge),o(s,We),o(s,He),o(s,Ve),"day");return me[o(this,Ee)].dateAdd(r,o(s,Se),o(s,Oe),o(s,Ke),c,a,this)}dateUntil(e,t,n){if(!Te(this))throw new TypeError("invalid receiver");const r=ae(e),s=ae(t),a=ct(z(n),"auto",["hour","minute","second","millisecond","microsecond","nanosecond"],"day"),{years:c,months:h,weeks:d,days:m}=me[o(this,Ee)].dateUntil(r,s,a);return new(F("%Temporal.Duration%"))(c,h,d,m,0,0,0,0,0,0)}year(e){let t=e;if(!Te(this))throw new TypeError("invalid receiver");return te(t)||(t=ae(t)),me[o(this,Ee)].year(t)}month(e){let t=e;if(!Te(this))throw new TypeError("invalid receiver");if(Ie(t))throw new TypeError("use monthCode on PlainMonthDay instead");return te(t)||(t=ae(t)),me[o(this,Ee)].month(t)}monthCode(e){let t=e;if(!Te(this))throw new TypeError("invalid receiver");return te(t)||Ie(t)||(t=ae(t)),me[o(this,Ee)].monthCode(t)}day(e){let t=e;if(!Te(this))throw new TypeError("invalid receiver");return Ie(t)||(t=ae(t)),me[o(this,Ee)].day(t)}era(e){let t=e;if(!Te(this))throw new TypeError("invalid receiver");return te(t)||(t=ae(t)),me[o(this,Ee)].era(t)}eraYear(e){let t=e;if(!Te(this))throw new TypeError("invalid receiver");return te(t)||(t=ae(t)),me[o(this,Ee)].eraYear(t)}dayOfWeek(e){if(!Te(this))throw new TypeError("invalid receiver");const t=ae(e);return me[o(this,Ee)].dayOfWeek(t)}dayOfYear(e){if(!Te(this))throw new TypeError("invalid receiver");const t=ae(e);return me[o(this,Ee)].dayOfYear(t)}weekOfYear(e){if(!Te(this))throw new TypeError("invalid receiver");const t=ae(e);return me[o(this,Ee)].weekOfYear(t)}daysInWeek(e){if(!Te(this))throw new TypeError("invalid receiver");const t=ae(e);return me[o(this,Ee)].daysInWeek(t)}daysInMonth(e){let t=e;if(!Te(this))throw new TypeError("invalid receiver");return te(t)||(t=ae(t)),me[o(this,Ee)].daysInMonth(t)}daysInYear(e){let t=e;if(!Te(this))throw new TypeError("invalid receiver");return te(t)||(t=ae(t)),me[o(this,Ee)].daysInYear(t)}monthsInYear(e){let t=e;if(!Te(this))throw new TypeError("invalid receiver");return te(t)||(t=ae(t)),me[o(this,Ee)].monthsInYear(t)}inLeapYear(e){let t=e;if(!Te(this))throw new TypeError("invalid receiver");return te(t)||(t=ae(t)),me[o(this,Ee)].inLeapYear(t)}toString(){if(!Te(this))throw new TypeError("invalid receiver");return o(this,Ee)}toJSON(){if(!Te(this))throw new TypeError("invalid receiver");return x(this)}static from(e){return Ze(e)}}function go(i){if(!i.startsWith("M"))throw new RangeError(`Invalid month code: ${i}.  Month codes must start with M.`);const e=+i.slice(1);if(isNaN(e))throw new RangeError(`Invalid month code: ${i}`);return e}function xt(i,e=!1){return`M${i.toString().padStart(2,"0")}${e?"L":""}`}function hr(i,e,t=12){let{month:n,monthCode:r}=i;if(r===void 0){if(n===void 0)throw new TypeError("Either month or monthCode are required");e==="reject"&&Ae(n,1,t),e==="constrain"&&(n=it(n,1,t)),r=xt(n)}else{const s=go(r);if(n!==void 0&&n!==s)throw new RangeError(`monthCode ${r} and month ${n} must match if both are present`);if(r!==xt(s))throw new RangeError(`Invalid month code: ${r}`);if(n=s,n<1||n>t)throw new RangeError(`Invalid monthCode: ${r}`)}return{...i,month:n,monthCode:r}}kt(fr,"Temporal.Calendar"),Jr("Temporal.Calendar.from",fr.from),me.iso8601={dateFromFields(i,e,t){const n=Le(e);let r=Fe(i,[["day"],["month",void 0],["monthCode",void 0],["year"]]);r=hr(r);let{year:s,month:a,day:c}=r;return{year:s,month:a,day:c}=wr(s,a,c,n),vt(s,a,c,t)},yearMonthFromFields(i,e,t){const n=Le(e);let r=Fe(i,[["month",void 0],["monthCode",void 0],["year"]]);r=hr(r);let{year:s,month:a}=r;return{year:s,month:a}=function(h,d,m){let u=h,f=d;const y=1;switch(m){case"reject":Ot(u,f,y);break;case"constrain":({year:u,month:f}=Bi(u,f))}return{year:u,month:f}}(s,a,n),zn(s,a,t,1)},monthDayFromFields(i,e,t){const n=Le(e);let r=Fe(i,[["day"],["month",void 0],["monthCode",void 0],["year",void 0]]);if(r.month!==void 0&&r.year===void 0&&r.monthCode===void 0)throw new TypeError("either year or monthCode required with month");const s=r.monthCode===void 0;r=hr(r);let{month:a,day:c,year:h}=r;return{month:a,day:c}=wr(s?h:1972,a,c,n),Un(a,c,t,1972)},fields:i=>i,mergeFields(i,e){const t={};for(const r of Vo(i))r!=="month"&&r!=="monthCode"&&(t[r]=i[r]);const n=Vo(e);for(const r of n)t[r]=e[r];if(!Fn.call(n,"month")&&!Fn.call(n,"monthCode")){const{month:r,monthCode:s}=i;r!==void 0&&(t.month=r),s!==void 0&&(t.monthCode=s)}return t},dateAdd(i,e,t,n,r,s,a){let c=o(i,R),h=o(i,$),d=o(i,I);return{year:c,month:h,day:d}=en(c,h,d,e,t,n,r,s),vt(c,h,d,a)},dateUntil:(i,e,t)=>ko(o(i,R),o(i,$),o(i,I),o(e,R),o(e,$),o(e,I),t),year:i=>o(i,R),era(){},eraYear(){},month:i=>o(i,$),monthCode:i=>xt(o(i,$)),day:i=>o(i,I),dayOfWeek:i=>Vr(o(i,R),o(i,$),o(i,I)),dayOfYear:i=>Er(o(i,R),o(i,$),o(i,I)),weekOfYear:i=>function(t,n,r){const s=Er(t,n,r),a=Vr(t,n,r)||7,c=Vr(t,1,1),h=$e((s-a+10)/7);return h<1?c===5||c===6&&Ut(t-1)?53:52:h===53&&(Ut(t)?366:365)-s<4-a?1:h}(o(i,R),o(i,$),o(i,I)),daysInWeek:()=>7,daysInMonth:i=>jt(o(i,R),o(i,$)),daysInYear(i){let e=i;return ke(e,R)||(e=ae(e)),Ut(o(e,R))?366:365},monthsInYear:()=>12,inLeapYear(i){let e=i;return ke(e,R)||(e=ae(e)),Ut(o(e,R))}};class fe{constructor(e){if(this.map=new Map,this.calls=0,this.hits=0,this.misses=0,this.now=globalThis.performance?globalThis.performance.now():Date.now(),e!==void 0){let t=0;for(const n of e.map.entries()){if(++t>fe.MAX_CACHE_ENTRIES)break;this.map.set(...n)}}}get(e){const t=this.map.get(e);return t&&(this.hits++,this.report()),this.calls++,t}set(e,t){this.map.set(e,t),this.misses++,this.report()}report(){}setObject(e){if(fe.objectMap.get(e))throw new RangeError("object already cached");fe.objectMap.set(e,this),this.report()}static getCacheForObject(e){let t=fe.objectMap.get(e);return t||(t=new fe,fe.objectMap.set(e,t)),t}}function mi({isoYear:i,isoMonth:e,isoDay:t}){return`${an(i)}-${ue(e)}-${ue(t)}T00:00Z`}function zr(i,e){return{years:i.year-e.year,months:i.month-e.month,days:i.day-e.day}}fe.objectMap=new WeakMap,fe.MAX_CACHE_ENTRIES=1e3;class Cn{constructor(){this.eraLength="short",this.hasEra=!0}getFormatter(){return this.formatter===void 0&&(this.formatter=new gs(`en-US-u-ca-${this.id}`,{day:"numeric",month:"numeric",year:"numeric",era:this.eraLength,timeZone:"UTC"})),this.formatter}isoToCalendarDate(e,t){const{year:n,month:r,day:s}=e,a=JSON.stringify({func:"isoToCalendarDate",isoYear:n,isoMonth:r,isoDay:s,id:this.id}),c=t.get(a);if(c)return c;const h=this.getFormatter();let d,m;try{m=mi({isoYear:n,isoMonth:r,isoDay:s}),d=h.formatToParts(new Date(m))}catch{throw new RangeError(`Invalid ISO date: ${JSON.stringify({isoYear:n,isoMonth:r,isoDay:s})}`)}const u={};for(let{type:y,value:g}of d){if(y==="year"&&(u.eraYear=+g),y==="relatedYear"&&(u.eraYear=+g),y==="month"){const w=/^([0-9]*)(.*?)$/.exec(g);if(!w||w.length!=3||!w[1]&&!w[2])throw new RangeError(`Unexpected month: ${g}`);if(u.month=w[1]?+w[1]:1,u.month<1)throw new RangeError(`Invalid month ${g} from ${m}[u-ca-${this.id}] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)`);if(u.month>13)throw new RangeError(`Invalid month ${g} from ${m}[u-ca-${this.id}] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)`);w[2]&&(u.monthExtra=w[2])}y==="day"&&(u.day=+g),this.hasEra&&y==="era"&&g!=null&&g!==""&&(g=g.split(" (")[0],u.era=g.normalize("NFD").replace(/[^-0-9 \p{L}]/gu,"").replace(" ","-").toLowerCase())}if(u.eraYear===void 0)throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);if(this.reviseIntlEra){const{era:y,eraYear:g}=this.reviseIntlEra(u,e);u.era=y,u.eraYear=g}this.checkIcuBugs&&this.checkIcuBugs(e);const f=this.adjustCalendarDate(u,t,"constrain",!0);if(f.year===void 0)throw new RangeError(`Missing year converting ${JSON.stringify(e)}`);if(f.month===void 0)throw new RangeError(`Missing month converting ${JSON.stringify(e)}`);if(f.day===void 0)throw new RangeError(`Missing day converting ${JSON.stringify(e)}`);return t.set(a,f),["constrain","reject"].forEach(y=>{const g=JSON.stringify({func:"calendarToIsoDate",year:f.year,month:f.month,day:f.day,overflow:y,id:this.id});t.set(g,e)}),f}validateCalendarDate(e){const{era:t,month:n,year:r,day:s,eraYear:a,monthCode:c,monthExtra:h}=e;if(h!==void 0)throw new RangeError("Unexpected `monthExtra` value");if(r===void 0&&a===void 0)throw new TypeError("year or eraYear is required");if(n===void 0&&c===void 0)throw new TypeError("month or monthCode is required");if(s===void 0)throw new RangeError("Missing day");if(c!==void 0){if(typeof c!="string")throw new RangeError("monthCode must be a string, not "+typeof c);if(!/^M([01]?\d)(L?)$/.test(c))throw new RangeError(`Invalid monthCode: ${c}`)}if(this.constantEra){if(t!==void 0&&t!==this.constantEra)throw new RangeError(`era must be ${this.constantEra}, not ${t}`);if(a!==void 0&&r!==void 0&&a!==r)throw new RangeError(`eraYear ${a} does not match year ${r}`)}}adjustCalendarDate(e,t,n="constrain",r=!1){if(this.calendarType==="lunisolar")throw new RangeError("Override required for lunisolar calendars");let s=e;if(this.validateCalendarDate(s),this.constantEra){const{year:d,eraYear:m}=s;s={...s,era:this.constantEra,year:d!==void 0?d:m,eraYear:m!==void 0?m:d}}const a=this.monthsInYear(s,t);let{month:c,monthCode:h}=s;return{month:c,monthCode:h}=hr(s,n,a),{...s,month:c,monthCode:h}}regulateMonthDayNaive(e,t,n){const r=this.monthsInYear(e,n);let{month:s,day:a}=e;return t==="reject"?(Ae(s,1,r),Ae(a,1,this.maximumMonthLength(e))):(s=it(s,1,r),a=it(a,1,this.maximumMonthLength({...e,month:s}))),{...e,month:s,day:a}}calendarToIsoDate(e,t="constrain",n){const r=e;let s=this.adjustCalendarDate(e,n,t,!1);s=this.regulateMonthDayNaive(s,t,n);const{year:a,month:c,day:h}=s,d=JSON.stringify({func:"calendarToIsoDate",year:a,month:c,day:h,overflow:t,id:this.id});let m,u=n.get(d);if(u||r.year!==void 0&&r.month!==void 0&&r.day!==void 0&&(r.year!==s.year||r.month!==s.month||r.day!==s.day)&&(m=JSON.stringify({func:"calendarToIsoDate",year:r.year,month:r.month,day:r.day,overflow:t,id:this.id}),u=n.get(m),u))return u;let f=this.estimateIsoDate({year:a,month:c,day:h});const y=b=>{let D=this.addDaysIso(f,b);if(s.day>this.minimumMonthLength(s)){let _=this.isoToCalendarDate(D,n);for(;_.month!==c||_.year!==a;){if(t==="reject")throw new RangeError(`day ${h} does not exist in month ${c} of year ${a}`);D=this.addDaysIso(D,-1),_=this.isoToCalendarDate(D,n)}}return D};let g=0,w=this.isoToCalendarDate(f,n),p=zr(s,w);if(p.years!==0||p.months!==0||p.days!==0){const b=365*p.years+30*p.months+p.days;f=this.addDaysIso(f,b),w=this.isoToCalendarDate(f,n),p=zr(s,w),p.years===0&&p.months===0?f=y(p.days):g=this.compareCalendarDates(s,w)}let v=8,T=!1;for(;g;){f=this.addDaysIso(f,g*v);const b=w;w=this.isoToCalendarDate(f,n);const D=g;if(g=this.compareCalendarDates(s,w),g){if(p=zr(s,w),p.years===0&&p.months===0)f=y(p.days),g=0,T=s.day>this.minimumMonthLength(s);else if(D&&g!==D)if(v>1)v/=2;else{if(t==="reject")throw new RangeError(`Can't find ISO date from calendar date: ${JSON.stringify({...r})}`);this.compareCalendarDates(w,b)>0&&(f=this.addDaysIso(f,-1)),T=!0,g=0}}}if(n.set(d,f),m&&n.set(m,f),s.year===void 0||s.month===void 0||s.day===void 0||s.monthCode===void 0||this.hasEra&&(s.era===void 0||s.eraYear===void 0))throw new RangeError("Unexpected missing property");if(!T){const b=JSON.stringify({func:"isoToCalendarDate",isoYear:f.year,isoMonth:f.month,isoDay:f.day,id:this.id});n.set(b,s)}return f}temporalToCalendarDate(e,t){const n={year:o(e,R),month:o(e,$),day:o(e,I)};return this.isoToCalendarDate(n,t)}compareCalendarDates(e,t){const n=Fe(e,[["day"],["month"],["year"]]),r=Fe(t,[["day"],["month"],["year"]]);return n.year!==r.year?tn(n.year-r.year):n.month!==r.month?tn(n.month-r.month):n.day!==r.day?tn(n.day-r.day):0}regulateDate(e,t="constrain",n){const r=this.calendarToIsoDate(e,t,n);return this.isoToCalendarDate(r,n)}addDaysIso(e,t){return en(e.year,e.month,e.day,0,0,0,t,"constrain")}addDaysCalendar(e,t,n){const r=this.calendarToIsoDate(e,"constrain",n),s=this.addDaysIso(r,t);return this.isoToCalendarDate(s,n)}addMonthsCalendar(e,t,n,r){let s=e;const{day:a}=s;for(let c=0,h=ps(t);c<h;c++){const{month:d}=s,m=s,u=t<0?-Math.max(a,this.daysInPreviousMonth(s,r)):this.daysInMonth(s,r),f=this.calendarToIsoDate(s,"constrain",r);let y=this.addDaysIso(f,u);if(s=this.isoToCalendarDate(y,r),t>0){const g=this.monthsInYear(m,r);for(;s.month-1!=d%g;)y=this.addDaysIso(y,-1),s=this.isoToCalendarDate(y,r)}s.day!==a&&(s=this.regulateDate({...s,day:a},"constrain",r))}if(n==="reject"&&s.day!==a)throw new RangeError(`Day ${a} does not exist in resulting calendar month`);return s}addCalendar(e,{years:t=0,months:n=0,weeks:r=0,days:s=0},a,c){const{year:h,month:d,day:m}=e,u=this.addMonthsCalendar({year:h+t,month:d,day:m},n,a,c),f=s+7*r;return this.addDaysCalendar(u,f,c)}untilCalendar(e,t,n,r){let s=0,a=0,c=0,h=0;switch(n){case"day":s=this.calendarDaysUntil(e,t,r);break;case"week":{const d=this.calendarDaysUntil(e,t,r);s=d%7,a=(d-s)/7;break}case"month":case"year":{const d=t.year-e.year,m=t.month-e.month,u=t.day-e.day,f=this.compareCalendarDates(t,e);n==="year"&&d&&(h=m*f<0||m===0&&u*f<0?d-f:d);let y,g=h?this.addCalendar(e,{years:h},"constrain",r):e;do c+=f,y=g,g=this.addMonthsCalendar(y,f,"constrain",r),g.day!==e.day&&(g=this.regulateDate({...g,day:e.day},"constrain",r));while(this.compareCalendarDates(t,g)*f>=0);c-=f,s=this.calendarDaysUntil(y,t,r);break}}return{years:h,months:c,weeks:a,days:s}}daysInMonth(e,t){const{day:n}=e,r=this.maximumMonthLength(e),s=this.minimumMonthLength(e);if(s===r)return s;const a=n<=r-s?r:s,c=this.calendarToIsoDate(e,"constrain",t),h=this.addDaysIso(c,a),d=this.isoToCalendarDate(h,t),m=this.addDaysIso(h,-d.day);return this.isoToCalendarDate(m,t).day}daysInPreviousMonth(e,t){const{day:n,month:r,year:s}=e;let a={year:r>1?s:s-1,month:r,day:1};const c=r>1?r-1:this.monthsInYear(a,t);a={...a,month:c};const h=this.minimumMonthLength(a),d=this.maximumMonthLength(a);if(h===d)return d;const m=this.calendarToIsoDate(e,"constrain",t),u=this.addDaysIso(m,-n);return this.isoToCalendarDate(u,t).day}startOfCalendarYear(e){return{year:e.year,month:1,day:1}}startOfCalendarMonth(e){return{year:e.year,month:e.month,day:1}}calendarDaysUntil(e,t,n){const r=this.calendarToIsoDate(e,"constrain",n),s=this.calendarToIsoDate(t,"constrain",n);return this.isoDaysUntil(r,s)}isoDaysUntil(e,t){return ko(e.year,e.month,e.day,t.year,t.month,t.day,"day").days}monthDayFromFields(e,t,n){let r,s,a,c,h,{year:d,month:m,monthCode:u,day:f,era:y,eraYear:g}=e;if(u===void 0){if(d===void 0&&(y===void 0||g===void 0))throw new TypeError("`monthCode`, `year`, or `era` and `eraYear` is required");({monthCode:u,year:d}=this.adjustCalendarDate({year:d,month:m,monthCode:u,day:f,era:y,eraYear:g},n,t))}const{year:w}=this.isoToCalendarDate({year:1972,month:1,day:1},n);for(let p=0;p<100;p++){const v=this.adjustCalendarDate({day:f,monthCode:u,year:w-p},n),T=this.calendarToIsoDate(v,"constrain",n),b=this.isoToCalendarDate(T,n);if({year:r,month:s,day:a}=T,b.monthCode===u&&b.day===f)return{month:s,day:a,year:r};t==="constrain"&&(c===void 0||b.monthCode===c.monthCode&&b.day>c.day)&&(c=b,h=T)}if(t==="constrain"&&h!==void 0)return h;throw new RangeError(`No recent ${this.id} year with monthCode ${u} and day ${f}`)}}class Ts extends Cn{constructor(){super(...arguments),this.id="hebrew",this.calendarType="lunisolar",this.months={Tishri:{leap:1,regular:1,monthCode:"M01",days:30},Heshvan:{leap:2,regular:2,monthCode:"M02",days:{min:29,max:30}},Kislev:{leap:3,regular:3,monthCode:"M03",days:{min:29,max:30}},Tevet:{leap:4,regular:4,monthCode:"M04",days:29},Shevat:{leap:5,regular:5,monthCode:"M05",days:30},Adar:{leap:void 0,regular:6,monthCode:"M06",days:29},"Adar I":{leap:6,regular:void 0,monthCode:"M05L",days:30},"Adar II":{leap:7,regular:void 0,monthCode:"M06",days:29},Nisan:{leap:8,regular:7,monthCode:"M07",days:30},Iyar:{leap:9,regular:8,monthCode:"M08",days:29},Sivan:{leap:10,regular:9,monthCode:"M09",days:30},Tamuz:{leap:11,regular:10,monthCode:"M10",days:29},Av:{leap:12,regular:11,monthCode:"M11",days:30},Elul:{leap:13,regular:12,monthCode:"M12",days:29}},this.hasEra=!1}inLeapYear(e){const{year:t}=e;return(7*t+1)%19<7}monthsInYear(e){return this.inLeapYear(e)?13:12}minimumMonthLength(e){return this.minMaxMonthLength(e,"min")}maximumMonthLength(e){return this.minMaxMonthLength(e,"max")}minMaxMonthLength(e,t){const{month:n,year:r}=e,s=this.getMonthCode(r,n),a=eo(this.months).find(h=>h[1].monthCode===s);if(a===void 0)throw new RangeError(`unmatched Hebrew month: ${n}`);const c=a[1].days;return typeof c=="number"?c:c[t]}estimateIsoDate(e){const{year:t}=e;return{year:t-3760,month:1,day:1}}getMonthCode(e,t){return this.inLeapYear({year:e})?t===6?xt(5,!0):xt(t<6?t:t-1):xt(t)}adjustCalendarDate(e,t,n="constrain",r=!1){let{year:s,eraYear:a,month:c,monthCode:h,day:d,monthExtra:m}=e;if(s===void 0&&a!==void 0&&(s=a),a===void 0&&s!==void 0&&(a=s),r){if(m){const u=this.months[m];if(!u)throw new RangeError(`Unrecognized month from formatToParts: ${m}`);c=this.inLeapYear({year:s})?u.leap:u.regular}return h=this.getMonthCode(s,c),{year:s,month:c,day:d,era:void 0,eraYear:a,monthCode:h}}if(this.validateCalendarDate(e),c===void 0)if(h.endsWith("L")){if(h!=="M05L")throw new RangeError(`Hebrew leap month must have monthCode M05L, not ${h}`);if(c=6,!this.inLeapYear({year:s})){if(n==="reject")throw new RangeError(`Hebrew monthCode M05L is invalid in year ${s} which is not a leap year`);c=5,d=30,h="M05"}}else{c=go(h),this.inLeapYear({year:s})&&c>6&&c++;const u=this.monthsInYear({year:s});if(c<1||c>u)throw new RangeError(`Invalid monthCode: ${h}`)}else if(n==="reject"?(Ae(c,1,this.monthsInYear({year:s})),Ae(d,1,this.maximumMonthLength({year:s,month:c}))):(c=it(c,1,this.monthsInYear({year:s})),d=it(d,1,this.maximumMonthLength({year:s,month:c}))),h===void 0)h=this.getMonthCode(s,c);else if(this.getMonthCode(s,c)!==h)throw new RangeError(`monthCode ${h} doesn't correspond to month ${c} in Hebrew year ${s}`);return{...e,day:d,month:c,monthCode:h,year:s,eraYear:a}}}class Mn extends Cn{constructor(){super(...arguments),this.calendarType="lunar",this.DAYS_PER_ISLAMIC_YEAR=354+11/30,this.DAYS_PER_ISO_YEAR=365.2425,this.constantEra="ah"}inLeapYear(e,t){return this.daysInMonth({year:e.year,month:12,day:1},t)===30}monthsInYear(){return 12}minimumMonthLength(){return 29}maximumMonthLength(){return 30}estimateIsoDate(e){const{year:t}=this.adjustCalendarDate(e);return{year:vs(t*this.DAYS_PER_ISLAMIC_YEAR/this.DAYS_PER_ISO_YEAR)+622,month:1,day:1}}}class fi extends Mn{constructor(){super(...arguments),this.id="islamic"}}class Es extends Mn{constructor(){super(...arguments),this.id="islamic-umalqura"}}class bs extends Mn{constructor(){super(...arguments),this.id="islamic-tbla"}}class Ds extends Mn{constructor(){super(...arguments),this.id="islamic-civil"}}class _s extends Mn{constructor(){super(...arguments),this.id="islamic-rgsa"}}class Cs extends Mn{constructor(){super(...arguments),this.id="islamicc"}}class Ms extends Cn{constructor(){super(...arguments),this.id="persian",this.calendarType="solar",this.constantEra="ap"}inLeapYear(e,t){return fi.prototype.inLeapYear.call(this,e,t)}monthsInYear(){return 12}minimumMonthLength(e){const{month:t}=e;return t===12?29:t<=6?31:30}maximumMonthLength(e){const{month:t}=e;return t===12?30:t<=6?31:30}estimateIsoDate(e){const{year:t}=this.adjustCalendarDate(e);return{year:t+621,month:1,day:1}}}class Os extends Cn{constructor(){super(...arguments),this.id="indian",this.calendarType="solar",this.constantEra="saka",this.months={1:{length:30,month:3,day:22,leap:{length:31,month:3,day:21}},2:{length:31,month:4,day:21},3:{length:31,month:5,day:22},4:{length:31,month:6,day:22},5:{length:31,month:7,day:23},6:{length:31,month:8,day:23},7:{length:30,month:9,day:23},8:{length:30,month:10,day:23},9:{length:30,month:11,day:22},10:{length:30,month:12,day:22},11:{length:30,month:1,nextYear:!0,day:21},12:{length:30,month:2,nextYear:!0,day:20}},this.vulnerableToBceBug=new Date("0000-01-01T00:00Z").toLocaleDateString("en-US-u-ca-indian",{timeZone:"UTC"})!=="10/11/-79 Saka"}inLeapYear(e){return yi(e.year+78)}monthsInYear(){return 12}minimumMonthLength(e){return this.getMonthInfo(e).length}maximumMonthLength(e){return this.getMonthInfo(e).length}getMonthInfo(e){const{month:t}=e;let n=this.months[t];if(n===void 0)throw new RangeError(`Invalid month: ${t}`);return this.inLeapYear(e)&&n.leap&&(n=n.leap),n}estimateIsoDate(e){const t=this.adjustCalendarDate(e),n=this.getMonthInfo(t);return en(t.year+78+(n.nextYear?1:0),n.month,n.day,0,0,0,t.day-1,"constrain")}checkIcuBugs(e){if(this.vulnerableToBceBug&&e.year<1)throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 0001-01-01 (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)`)}}function yi(i){return i%4==0&&(i%100!=0||i%400==0)}class Hn extends Cn{constructor(e,t){super(),this.calendarType="solar",this.v8IsVulnerableToJulianBug=new Date("+001001-01-01T00:00Z").toLocaleDateString("en-US-u-ca-japanese",{timeZone:"UTC"}).startsWith("12"),this.calendarIsVulnerableToJulianBug=!1,this.id=e;const{eras:n,anchorEra:r}=function(a){let c,h=a;if(h.length===0)throw new RangeError("Invalid era data: eras are required");if(h.length===1&&h[0].reverseOf)throw new RangeError("Invalid era data: anchor era cannot count years backwards");if(h.length===1&&!h[0].name)throw new RangeError("Invalid era data: at least one named era is required");if(h.filter(m=>m.reverseOf!=null).length>1)throw new RangeError("Invalid era data: only one era can count years backwards");h.forEach(m=>{if(m.isAnchor||!m.anchorEpoch&&!m.reverseOf){if(c)throw new RangeError("Invalid era data: cannot have multiple anchor eras");c=m,m.anchorEpoch={year:m.hasYearZero?0:1}}else if(!m.name)throw new RangeError("If era name is blank, it must be the anchor era")}),h=h.filter(m=>m.name),h.forEach(m=>{const{reverseOf:u}=m;if(u){const f=h.find(y=>y.name===u);if(f===void 0)throw new RangeError(`Invalid era data: unmatched reverseOf era: ${u}`);m.reverseOf=f,m.anchorEpoch=f.anchorEpoch,m.isoEpoch=f.isoEpoch}m.anchorEpoch.month===void 0&&(m.anchorEpoch.month=1),m.anchorEpoch.day===void 0&&(m.anchorEpoch.day=1)}),ws.call(h,(m,u)=>{if(m.reverseOf)return 1;if(u.reverseOf)return-1;if(!m.isoEpoch||!u.isoEpoch)throw new RangeError("Invalid era data: missing ISO epoch");return u.isoEpoch.year-m.isoEpoch.year});const d=h[h.length-1].reverseOf;if(d&&d!==h[h.length-2])throw new RangeError("Invalid era data: invalid reverse-sign era");return h.forEach((m,u)=>{m.genericName="era"+(h.length-1-u)}),{eras:h,anchorEra:c||h[0]}}(t);this.anchorEra=r,this.eras=n}inLeapYear(e){const{year:t}=this.estimateIsoDate({month:1,day:1,year:e.year});return yi(t)}monthsInYear(){return 12}minimumMonthLength(e){const{month:t}=e;return t===2?this.inLeapYear(e)?29:28:[4,6,9,11].indexOf(t)>=0?30:31}maximumMonthLength(e){return this.minimumMonthLength(e)}completeEraYear(e){const t=(c,h)=>{const d=e[c];if(d!=null&&d!=h)throw new RangeError(`Input ${c} ${d} doesn't match calculated value ${h}`)},n=c=>{let h;const d={...e,year:c},m=this.eras.find((u,f)=>{if(f===this.eras.length-1){if(u.reverseOf){if(c>0)throw new RangeError(`Signed year ${c} is invalid for era ${u.name}`);return h=u.anchorEpoch.year-c,!0}return h=c-u.anchorEpoch.year+(u.hasYearZero?0:1),!0}return this.compareCalendarDates(d,u.anchorEpoch)>=0&&(h=c-u.anchorEpoch.year+(u.hasYearZero?0:1),!0)});if(!m)throw new RangeError(`Year ${c} was not matched by any era`);return{eraYear:h,era:m.name}};let{year:r,eraYear:s,era:a}=e;if(r!=null)({eraYear:s,era:a}=n(r)),t("era",a),t("eraYear",s);else{if(s==null)throw new RangeError("Either `year` or `eraYear` and `era` are required");{const c=a===void 0?void 0:this.eras.find(h=>h.name===a||h.genericName===a);if(!c)throw new RangeError(`Era ${a} (ISO year ${s}) was not matched by any era`);if(s<1&&c.reverseOf)throw new RangeError(`Years in ${a} era must be positive, not ${r}`);r=c.reverseOf?c.anchorEpoch.year-s:s+c.anchorEpoch.year-(c.hasYearZero?0:1),t("year",r),{eraYear:s,era:a}=n(r)}}return{...e,year:r,eraYear:s,era:a}}adjustCalendarDate(e,t,n="constrain"){let r=e;const{month:s,monthCode:a}=r;return s===void 0&&(r={...r,month:go(a)}),this.validateCalendarDate(r),r=this.completeEraYear(r),super.adjustCalendarDate(r,t,n)}estimateIsoDate(e){const t=this.adjustCalendarDate(e),{year:n,month:r,day:s}=t,{anchorEra:a}=this;return wr(n+a.isoEpoch.year-(a.hasYearZero?0:1),r,s,"constrain")}checkIcuBugs(e){if(this.calendarIsVulnerableToJulianBug&&this.v8IsVulnerableToJulianBug&&Lt(e.year,e.month,e.day,1582,10,15)<0)throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 1582-10-15 (see https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)`)}}class wo extends Hn{constructor(e,t){super(e,t)}inLeapYear(e){const{year:t}=e;return(t+1)%4==0}monthsInYear(){return 13}minimumMonthLength(e){const{month:t}=e;return t===13?this.inLeapYear(e)?6:5:30}maximumMonthLength(e){return this.minimumMonthLength(e)}}class Rs extends wo{constructor(){super("ethioaa",[{name:"era0",isoEpoch:{year:-5492,month:7,day:17}}])}}class $s extends wo{constructor(){super("coptic",[{name:"era1",isoEpoch:{year:284,month:8,day:29}},{name:"era0",reverseOf:"era1"}])}}class ks extends wo{constructor(){super("ethiopic",[{name:"era0",isoEpoch:{year:-5492,month:7,day:17}},{name:"era1",isoEpoch:{year:8,month:8,day:27},anchorEpoch:{year:5501}}])}}class Is extends Hn{constructor(){super("roc",[{name:"minguo",isoEpoch:{year:1912,month:1,day:1}},{name:"before-roc",reverseOf:"minguo"}]),this.calendarIsVulnerableToJulianBug=!0}}class Ys extends Hn{constructor(){super("buddhist",[{name:"be",hasYearZero:!0,isoEpoch:{year:-543,month:1,day:1}}]),this.calendarIsVulnerableToJulianBug=!0}}class Ns extends Hn{constructor(){super("gregory",[{name:"ce",isoEpoch:{year:1,month:1,day:1}},{name:"bce",reverseOf:"ce"}])}reviseIntlEra(e){let{era:t,eraYear:n}=e;return t!=="bc"&&t!=="b"||(t="bce"),t!=="ad"&&t!=="a"||(t="ce"),{era:t,eraYear:n}}}class Ps extends Hn{constructor(){super("japanese",[{name:"reiwa",isoEpoch:{year:2019,month:5,day:1},anchorEpoch:{year:2019,month:5,day:1}},{name:"heisei",isoEpoch:{year:1989,month:1,day:8},anchorEpoch:{year:1989,month:1,day:8}},{name:"showa",isoEpoch:{year:1926,month:12,day:25},anchorEpoch:{year:1926,month:12,day:25}},{name:"taisho",isoEpoch:{year:1912,month:7,day:30},anchorEpoch:{year:1912,month:7,day:30}},{name:"meiji",isoEpoch:{year:1868,month:9,day:8},anchorEpoch:{year:1868,month:9,day:8}},{name:"ce",isoEpoch:{year:1,month:1,day:1}},{name:"bce",reverseOf:"ce"}]),this.calendarIsVulnerableToJulianBug=!0,this.eraLength="long"}reviseIntlEra(e,t){const{era:n,eraYear:r}=e,{year:s}=t;return this.eras.find(a=>a.name===n)?{era:n,eraYear:r}:s<1?{era:"bce",eraYear:1-s}:{era:"ce",eraYear:s}}}class gi extends Cn{constructor(){super(...arguments),this.calendarType="lunisolar",this.hasEra=!1}inLeapYear(e,t){const n=this.getMonthList(e.year,t);return eo(n).length===13}monthsInYear(e,t){return this.inLeapYear(e,t)?13:12}minimumMonthLength(){return 29}maximumMonthLength(){return 30}getMonthList(e,t){if(e===void 0)throw new TypeError("Missing year");const n=JSON.stringify({func:"getMonthList",calendarYear:e,id:this.id}),r=t.get(n);if(r)return r;const s=this.getFormatter(),a=(p,v)=>{const T=mi({isoYear:p,isoMonth:2,isoDay:1}),b=new Date(T);b.setUTCDate(v+1);const D=s.formatToParts(b),_=D.find(k=>k.type==="month").value,C=+D.find(k=>k.type==="day").value;let M=D.find(k=>k.type==="relatedYear");if(M===void 0)throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);return M=+M.value,{calendarMonthString:_,calendarDay:C,calendarYearToVerify:M}};let c=17,{calendarMonthString:h,calendarDay:d,calendarYearToVerify:m}=a(e,c);h!=="1"&&(c+=29,{calendarMonthString:h,calendarDay:d}=a(e,c)),c-=d-5;const u={};let f,y,g=1,w=!1;do({calendarMonthString:h,calendarDay:d,calendarYearToVerify:m}=a(e,c)),f&&(u[y].daysInMonth=f+30-d),m!==e?w=!0:(u[h]={monthIndex:g++},c+=30),f=d,y=h;while(!w);return u[y].daysInMonth=f+30-d,t.set(n,u),u}estimateIsoDate(e){const{year:t,month:n}=e;return{year:t,month:n>=12?12:n+1,day:1}}adjustCalendarDate(e,t,n="constrain",r=!1){let{year:s,month:a,monthExtra:c,day:h,monthCode:d,eraYear:m}=e;if(r){if(s=m,c&&c!=="bis")throw new RangeError(`Unexpected leap month suffix: ${c}`);const u=xt(a,c!==void 0),f=`${a}${c||""}`,y=this.getMonthList(s,t)[f];if(y===void 0)throw new RangeError(`Unmatched month ${f} in Chinese year ${s}`);return a=y.monthIndex,{year:s,month:a,day:h,era:void 0,eraYear:m,monthCode:u}}if(this.validateCalendarDate(e),s===void 0&&(s=m),m===void 0&&(m=s),a===void 0){const u=this.getMonthList(s,t);let f=d.replace("L","bis").slice(1);f[0]==="0"&&(f=f.slice(1));let y=u[f];if(a=y&&y.monthIndex,a===void 0&&d.endsWith("L")&&!Fn.call(["M01L","M12L","M13L"],d)&&n==="constrain"){let g=d.slice(1,-1);g[0]==="0"&&(g=g.slice(1)),y=u[g],y&&({daysInMonth:h,monthIndex:a}=y,d=xt(g))}if(a===void 0)throw new RangeError(`Unmatched month ${d} in Chinese year ${s}`)}else if(d===void 0){const u=this.getMonthList(s,t),f=eo(u),y=f.length;n==="reject"?(Ae(a,1,y),Ae(h,1,this.maximumMonthLength())):(a=it(a,1,y),h=it(h,1,this.maximumMonthLength()));const g=f.find(([,w])=>w.monthIndex===a);if(g===void 0)throw new RangeError(`Invalid month ${a} in Chinese year ${s}`);d=xt(g[0].replace("bis",""),g[0].indexOf("bis")!==-1)}else{const u=this.getMonthList(s,t);let f=d.replace("L","bis").slice(1);f[0]==="0"&&(f=f.slice(1));const y=u[f];if(!y)throw new RangeError(`Unmatched monthCode ${d} in Chinese year ${s}`);if(a!==y.monthIndex)throw new RangeError(`monthCode ${d} doesn't correspond to month ${a} in Chinese year ${s}`)}return{...e,year:s,eraYear:m,month:a,monthCode:d,day:h}}}class Ls extends gi{constructor(){super(...arguments),this.id="chinese"}}class Fs extends gi{constructor(){super(...arguments),this.id="dangi"}}const xs={helper:void 0,dateFromFields(i,e,t){const n=Le(e),r=new fe,s=Fe(i,[["day"],["era",void 0],["eraYear",void 0],["month",void 0],["monthCode",void 0],["year",void 0]]),{year:a,month:c,day:h}=this.helper.calendarToIsoDate(s,n,r),d=vt(a,c,h,t);return r.setObject(d),d},yearMonthFromFields(i,e,t){const n=Le(e),r=new fe,s=Fe(i,[["era",void 0],["eraYear",void 0],["month",void 0],["monthCode",void 0],["year",void 0]]),{year:a,month:c,day:h}=this.helper.calendarToIsoDate({...s,day:1},n,r),d=zn(a,c,t,h);return r.setObject(d),d},monthDayFromFields(i,e,t){const n=Le(e),r=new fe,s=Fe(i,[["day"],["era",void 0],["eraYear",void 0],["month",void 0],["monthCode",void 0],["year",void 0]]),{year:a,month:c,day:h}=this.helper.monthDayFromFields(s,n,r),d=Un(c,h,t,a);return r.setObject(d),d},fields(i){let e=i;return Fn.call(e,"year")&&(e=[...e,"era","eraYear"]),e},mergeFields(i,e){const t={...i},n={...e},{month:r,monthCode:s,year:a,era:c,eraYear:h,...d}=t,{month:m,monthCode:u,year:f,era:y,eraYear:g}=n;return m===void 0&&u===void 0&&(d.month=r,d.monthCode=s),f===void 0&&y===void 0&&g===void 0&&(d.year=a),{...d,...n}},dateAdd(i,e,t,n,r,s,a){const c=fe.getCacheForObject(i),h=this.helper.temporalToCalendarDate(i,c),d=this.helper.addCalendar(h,{years:e,months:t,weeks:n,days:r},s,c),m=this.helper.calendarToIsoDate(d,"constrain",c),{year:u,month:f,day:y}=m,g=vt(u,f,y,a);return new fe(c).setObject(g),g},dateUntil(i,e,t){const n=fe.getCacheForObject(i),r=fe.getCacheForObject(e),s=this.helper.temporalToCalendarDate(i,n),a=this.helper.temporalToCalendarDate(e,r);return this.helper.untilCalendar(s,a,t,n)},year(i){const e=fe.getCacheForObject(i);return this.helper.temporalToCalendarDate(i,e).year},month(i){const e=fe.getCacheForObject(i);return this.helper.temporalToCalendarDate(i,e).month},day(i){const e=fe.getCacheForObject(i);return this.helper.temporalToCalendarDate(i,e).day},era(i){if(!this.helper.hasEra)return;const e=fe.getCacheForObject(i);return this.helper.temporalToCalendarDate(i,e).era},eraYear(i){if(!this.helper.hasEra)return;const e=fe.getCacheForObject(i);return this.helper.temporalToCalendarDate(i,e).eraYear},monthCode(i){const e=fe.getCacheForObject(i);return this.helper.temporalToCalendarDate(i,e).monthCode},dayOfWeek:i=>me.iso8601.dayOfWeek(i),dayOfYear(i){const e=fe.getCacheForObject(i),t=this.helper.isoToCalendarDate(i,e),n=this.helper.startOfCalendarYear(t);return this.helper.calendarDaysUntil(n,t,e)+1},weekOfYear:i=>me.iso8601.weekOfYear(i),daysInWeek:i=>me.iso8601.daysInWeek(i),daysInMonth(i){const e=fe.getCacheForObject(i),t=this.helper.temporalToCalendarDate(i,e),n=this.helper.maximumMonthLength(t);if(n===this.helper.minimumMonthLength(t))return n;const r=this.helper.startOfCalendarMonth(t),s=this.helper.addMonthsCalendar(r,1,"constrain",e);return this.helper.calendarDaysUntil(r,s,e)},daysInYear(i){let e=i;ke(e,R)||(e=ae(e));const t=fe.getCacheForObject(e),n=this.helper.temporalToCalendarDate(e,t),r=this.helper.startOfCalendarYear(n),s=this.helper.addCalendar(r,{years:1},"constrain",t);return this.helper.calendarDaysUntil(r,s,t)},monthsInYear(i){const e=fe.getCacheForObject(i),t=this.helper.temporalToCalendarDate(i,e);return this.helper.monthsInYear(t,e)},inLeapYear(i){let e=i;ke(e,R)||(e=ae(e));const t=fe.getCacheForObject(e),n=this.helper.temporalToCalendarDate(e,t);return this.helper.inLeapYear(n,t)}};for(const i of[Ts,Ms,ks,Rs,$s,Ls,Fs,Is,Os,Ys,Ns,Ps,fi,Es,bs,Ds,_s,Cs]){const e=new i;me[e.id]={...xs,helper:e}}const Zs=Object.keys(me);function wi(i){return Fn.call(Zs,i)}const Bo=/\.[-A-Za-z_]|\.\.[-A-Za-z._]{1,12}|\.[-A-Za-z_][-A-Za-z._]{0,12}|[A-Za-z_][-A-Za-z._]{0,13}/,js=new RegExp(`(?:(?:${Bo.source})(?:\\/(?:${Bo.source}))*|Etc/GMT[-+]\\d{1,2}|${/(?:[+\u2212-][0-2][0-9](?::?[0-5][0-9](?::?[0-5][0-9](?:[.,]\d{1,9})?)?)?)/.source})`),Xo=/[A-Za-z0-9]{3,8}/,As=new RegExp(`(?:${Xo.source}(?:-${Xo.source})*)`),pi=/(?:[+\u2212-]\d{6}|\d{4})/,yr=/(?:0[1-9]|1[0-2])/,to=/(?:0[1-9]|[12]\d|3[01])/,Ss=new RegExp(`(${pi.source})(?:-(${yr.source})-(${to.source})|(${yr.source})(${to.source}))`),vi=/(\d{2})(?::(\d{2})(?::(\d{2})(?:[.,](\d{1,9}))?)?|(\d{2})(?:(\d{2})(?:[.,](\d{1,9}))?)?)?/,Ti=/([+\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\d{1,9}))?)?)?/,Ei=new RegExp(`(?:([zZ])|(?:${Ti.source})?)(?:\\[(${js.source})\\])?`),bi=new RegExp(`\\[u-ca=(${As.source})\\]`),qs=new RegExp(`^${Ss.source}(?:(?:T|\\s+)${vi.source})?${Ei.source}(?:${bi.source})?$`,"i"),Us=new RegExp(`^T?${vi.source}(?:${Ei.source})?(?:${bi.source})?$`,"i"),zs=new RegExp(`^(${pi.source})-?(${yr.source})$`),Gs=new RegExp(`^(?:--)?(${yr.source})-?(${to.source})$`),Gr=/(\d+)(?:[.,](\d{1,9}))?/,Ws=new RegExp(`(?:${Gr.source}H)?(?:${Gr.source}M)?(?:${Gr.source}S)?`),Hs=new RegExp(`^([+\u2212-])?P${/(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?/.source}(?:T(?!$)${Ws.source})?$`,"i"),Di=Array.prototype.push,_i=globalThis.Intl.DateTimeFormat,Vs=Math.min,Bs=Math.max,ee=Math.abs,$e=Math.floor,xn=Math.sign,un=Math.trunc,Vn=Number.isNaN,Pe=Number.isFinite,Xs=Number,Bn=String,Qs=Number.MAX_SAFE_INTEGER,le=Object.create,Ks=Object.is,po=Reflect.apply,be=l.BigInt(0),vo=l.BigInt(1),Qt=l.BigInt(60),re=l.BigInt(1e3),dt=l.BigInt(1e6),Zt=l.BigInt(1e9),Js=l.BigInt(-1),Gt=l.multiply(l.BigInt(86400),Zt),Zn=l.multiply(l.BigInt(-86400),l.BigInt(1e17)),jn=l.multiply(l.BigInt(86400),l.BigInt(1e17)),Ci=l.multiply(l.BigInt(-388152),l.BigInt(1e13)),ea=l.multiply(Gt,l.BigInt(3660)),Mi=l.multiply(Gt,l.BigInt(366)),Oi=l.multiply(Gt,l.BigInt(14));function Ri(i){if(typeof i!="number"||!Pe(i))return!1;const e=ee(i);return $e(e)===e}function he(i){return typeof i=="object"&&i!==null||typeof i=="function"}function An(i){if(typeof i=="bigint")throw new TypeError("Cannot convert BigInt to number");return Xs(i)}function oe(i){const e=An(i);if(Vn(e))return 0;const t=un(e);return e===0?0:t}function x(i){if(typeof i=="symbol")throw new TypeError("Cannot convert a Symbol value to a String");return Bn(i)}function ce(i){const e=oe(i);if(!Pe(e))throw new RangeError("infinity is out of range");return e}function pn(i,e){const t=oe(i);if(!Pe(t))throw new RangeError("infinity is out of range");if(t<1)throw e!==void 0?new RangeError(`property '${e}' cannot be a a number less than one`):new RangeError("Cannot convert a number less than one to a positive integer");return t}function Ye(i){const e=An(i);if(Vn(e))return 0;if(!Pe(e))throw new RangeError("infinity is out of range");if(!Ri(e))throw new RangeError(`unsupported fractional value ${e}`);return oe(e)}function Re(i,e){return{quotient:l.divide(i,e),remainder:l.remainder(i,e)}}function To(i){return l.lessThan(i,be)?l.multiply(i,Js):i}const gr=new Map([["year",ce],["month",pn],["monthCode",x],["day",pn],["hour",ce],["minute",ce],["second",ce],["millisecond",ce],["microsecond",ce],["nanosecond",ce],["years",Ye],["months",Ye],["weeks",Ye],["days",Ye],["hours",Ye],["minutes",Ye],["seconds",Ye],["milliseconds",Ye],["microseconds",Ye],["nanoseconds",Ye],["era",x],["eraYear",oe],["offset",x]]),vn=["year","month","week","day","hour","minute","second","millisecond","microsecond","nanosecond"],Rr=[["years","year"],["months","month"],["weeks","week"],["days","day"],["hours","hour"],["minutes","minute"],["seconds","second"],["milliseconds","millisecond"],["microseconds","microsecond"],["nanoseconds","nanosecond"]],Qo=new Map;function $i(i){let e=Qo.get(i);return e===void 0&&(e=new _i("en-us",{timeZone:Bn(i),hour12:!1,era:"short",year:"numeric",month:"numeric",day:"numeric",hour:"numeric",minute:"numeric",second:"numeric"}),Qo.set(i,e)),e}function Ce(i){return ke(i,P)&&!ke(i,J,E)}function Dt(i){return ke(i,At)}function Te(i){return ke(i,Ee)}function ge(i){return ke(i,Se,Oe,qe,Ue,ze,Ge,We,He,Ve)}function X(i){return ke(i,"slot-date-brand")}function we(i){return ke(i,Z,j,A,S,q,U)&&!ke(i,R,$,I)}function W(i){return ke(i,R,$,I,Z,j,A,S,q,U)}function te(i){return ke(i,"slot-year-month-brand")}function Ie(i){return ke(i,"slot-month-day-brand")}function Y(i){return ke(i,P,J,E)}function On(i){if(ke(i,E)||ke(i,J))throw new TypeError("with() does not support a calendar or timeZone property");if(i.calendar!==void 0)throw new TypeError("with() does not support a calendar property");if(i.timeZone!==void 0)throw new TypeError("with() does not support a timeZone property")}function ki(i){let{ianaName:e,offset:t,z:n}=function(s){try{let a=Oo(s);if(a)return a=a.toString(),mn(a)?{offset:a}:{ianaName:a}}catch{}try{const a=Yt(s);if(a.z||a.offset||a.ianaName)return a}catch{}throw new RangeError(`Invalid time zone: ${s}`)}(i);return e||(n?"UTC":t)}function Xn(i,e){return e==="never"||e==="auto"&&i==="iso8601"?"":`[u-ca=${i}]`}function Yt(i){const e=qs.exec(i);if(!e)throw new RangeError(`invalid ISO 8601 string: ${i}`);let t=e[1];if(t[0]==="\u2212"&&(t=`-${t.slice(1)}`),t==="-000000")throw new RangeError(`invalid ISO 8601 string: ${i}`);const n=oe(t),r=oe(e[2]||e[4]),s=oe(e[3]||e[5]),a=oe(e[6]),c=e[6]!==void 0,h=oe(e[7]||e[10]);let d=oe(e[8]||e[11]);d===60&&(d=59);const m=(e[9]||e[12])+"000000000",u=oe(m.slice(0,3)),f=oe(m.slice(3,6)),y=oe(m.slice(6,9));let g,w=!1;if(e[13])g=void 0,w=!0;else if(e[14]&&e[15]){const v=e[14]==="-"||e[14]==="\u2212"?"-":"+",T=e[15]||"00",b=e[16]||"00",D=e[17]||"00";let _=e[18]||"0";if(g=`${v}${T}:${b}`,+_){for(;_.endsWith("0");)_=_.slice(0,-1);g+=`:${D}.${_}`}else+D&&(g+=`:${D}`);g==="-00:00"&&(g="+00:00")}let p=e[19];if(p)try{p=Oo(p).toString()}catch{}return{year:n,month:r,day:s,hasTime:c,hour:a,minute:h,second:d,millisecond:u,microsecond:f,nanosecond:y,ianaName:p,offset:g,z:w,calendar:e[20]}}function Ii(i){const e=zs.exec(i);let t,n,r,s;if(e){let a=e[1];if(a[0]==="\u2212"&&(a=`-${a.slice(1)}`),a==="-000000")throw new RangeError(`invalid ISO 8601 string: ${i}`);t=oe(a),n=oe(e[2]),r=e[3]}else{let a;if({year:t,month:n,calendar:r,day:s,z:a}=Yt(i),a)throw new RangeError("Z designator not supported for PlainYearMonth")}return{year:t,month:n,calendar:r,referenceISODay:s}}function Yi(i){const e=Gs.exec(i);let t,n,r,s;if(e)t=oe(e[1]),n=oe(e[2]);else{let a;if({month:t,day:n,calendar:r,year:s,z:a}=Yt(i),a)throw new RangeError("Z designator not supported for PlainMonthDay")}return{month:t,day:n,calendar:r,referenceISOYear:s}}function Ni(i){const e=Hs.exec(i);if(!e)throw new RangeError(`invalid duration: ${i}`);if(e.slice(2).every(p=>p===void 0))throw new RangeError(`invalid duration: ${i}`);const t=e[1]==="-"||e[1]==="\u2212"?-1:1,n=oe(e[2])*t,r=oe(e[3])*t,s=oe(e[4])*t,a=oe(e[5])*t,c=oe(e[6])*t;let h=e[7],d=oe(e[8])*t,m=e[9],u=oe(e[10])*t;const f=e[11]+"000000000";let y=oe(f.slice(0,3))*t,g=oe(f.slice(3,6))*t,w=oe(f.slice(6,9))*t;return h=h?t*oe(h)/10**h.length:0,m=m?t*oe(m)/10**m.length:0,{minutes:d,seconds:u,milliseconds:y,microseconds:g,nanoseconds:w}=function(v,T,b,D,_,C,M){let k=v,N=T,K=b,Q=D,V=_,L=C,G=M;if(k!==0){[N,K,Q,V,L,G].forEach(B=>{if(B!==0)throw new RangeError("only the smallest unit can be fractional")});const O=60*k;N=un(O),K=O%1}if(K!==0){[Q,V,L,G].forEach(ie=>{if(ie!==0)throw new RangeError("only the smallest unit can be fractional")});const O=60*K;Q=un(O);const B=O%1;if(B!==0){const ie=1e3*B;V=un(ie);const ne=ie%1;if(ne!==0){const se=1e3*ne;L=un(se);const ye=se%1;ye!==0&&(G=un(1e3*ye))}}}return{minutes:N,seconds:Q,milliseconds:V,microseconds:L,nanoseconds:G}}(h,d,m,u,y,g,w),{years:n,months:r,weeks:s,days:a,hours:c,minutes:d,seconds:u,milliseconds:y,microseconds:g,nanoseconds:w}}function ta(i){const{year:e,month:t,day:n,hour:r,minute:s,second:a,millisecond:c,microsecond:h,nanosecond:d,offset:m,z:u}=function(w){const p=Yt(w);if(!p.z&&!p.offset)throw new RangeError("Temporal.Instant requires a time zone offset");return p}(i),f=Wt(e,t,n,r,s,a,c,h,d);if(f===null)throw new RangeError("DateTime outside of supported range");const y=u?0:on(m);return l.subtract(f,l.BigInt(y))}function wr(i,e,t,n){let r=i,s=e,a=t;switch(n){case"reject":Ot(r,s,a);break;case"constrain":({year:r,month:s,day:a}=Bi(r,s,a))}return{year:r,month:s,day:a}}function Nn(i,e,t,n,r,s,a){let c=i,h=e,d=t,m=n,u=r,f=s;switch(a){case"reject":Zr(c,h,d,m,u,f);break;case"constrain":({hour:c,minute:h,second:d,millisecond:m,microsecond:u,nanosecond:f}=function(g,w,p,v,T,b){const D=it(g,0,23),_=it(w,0,59),C=it(p,0,59),M=it(v,0,999),k=it(T,0,999),N=it(b,0,999);return{hour:D,minute:_,second:C,millisecond:M,microsecond:k,nanosecond:N}}(c,h,d,m,u,f))}return{hour:c,minute:h,second:d,millisecond:m,microsecond:u,nanosecond:f}}function Pi(i){if(ge(i))return{years:o(i,Se),months:o(i,Oe),weeks:o(i,Ke),days:o(i,qe),hours:o(i,Ue),minutes:o(i,ze),seconds:o(i,Ge),milliseconds:o(i,We),microseconds:o(i,He),nanoseconds:o(i,Ve)};const e=Ht(i,["days","hours","microseconds","milliseconds","minutes","months","nanoseconds","seconds","weeks","years"]);if(!e)throw new TypeError("invalid duration-like");const{years:t=0,months:n=0,weeks:r=0,days:s=0,hours:a=0,minutes:c=0,seconds:h=0,milliseconds:d=0,microseconds:m=0,nanoseconds:u=0}=e;return{years:t,months:n,weeks:r,days:s,hours:a,minutes:c,seconds:h,milliseconds:d,microseconds:m,nanoseconds:u}}function wt(i,e=[]){let t;he(i)?t=Pi(i):t=Ni(x(i));const{years:n,months:r,weeks:s,days:a,hours:c,minutes:h,seconds:d,milliseconds:m,microseconds:u,nanoseconds:f}=t;Ji(n,r,s,a,c,h,d,m,u,f);for(const y of e)if(t[y]!==0)throw new RangeError(`Duration field ${y} not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead.`);return t}function Le(i){return Rt(i,"overflow",["constrain","reject"],"constrain")}function Sn(i){return Rt(i,"disambiguation",["compatible","earlier","later","reject"],"compatible")}function Me(i,e){return Rt(i,"roundingMode",["ceil","floor","trunc","halfExpand"],e)}function Qn(i){switch(i){case"ceil":return"floor";case"floor":return"ceil";default:return i}}function no(i,e){return Rt(i,"offset",["prefer","use","ignore","reject"],e)}function Kn(i){return Rt(i,"calendarName",["auto","always","never"],"auto")}function ut(i,e,t){let n=1/0;e!==void 0&&(n=e),t||e===void 0||(n=e>1?e-1:1);const r=function(a,c,h,d,m){let u=a[c];if(u===void 0)return m;const f=An(u);if(Vn(f)||f<h||f>d)throw new RangeError(`${c} must be between ${h} and ${d}, not ${f}`);return $e(f)}(i,"roundingIncrement",1,n,1);if(e!==void 0&&e%r!=0)throw new RangeError(`Rounding increment must divide evenly into ${e}`);return r}function qn(i,e){return ut(i,{year:void 0,month:void 0,week:void 0,day:void 0,hour:24,minute:60,second:60,millisecond:1e3,microsecond:1e3,nanosecond:1e3}[e],!1)}function Jn(i){switch(Qe(i,void 0,["year","month","week","day","hour"])){case"minute":return{precision:"minute",unit:"minute",increment:1};case"second":return{precision:0,unit:"second",increment:1};case"millisecond":return{precision:3,unit:"millisecond",increment:1};case"microsecond":return{precision:6,unit:"microsecond",increment:1};case"nanosecond":return{precision:9,unit:"nanosecond",increment:1}}let e=i.fractionalSecondDigits;if(e===void 0&&(e="auto"),typeof e!="number"){const n=x(e);if(n==="auto")return{precision:"auto",unit:"nanosecond",increment:1};throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${n}`)}if(Vn(e)||e<0||e>9)throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${e}`);const t=$e(e);switch(t){case 0:return{precision:t,unit:"second",increment:1};case 1:case 2:case 3:return{precision:t,unit:"millisecond",increment:10**(3-t)};case 4:case 5:case 6:return{precision:t,unit:"microsecond",increment:10**(6-t)};case 7:case 8:case 9:return{precision:t,unit:"nanosecond",increment:10**(9-t)};default:throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${e}`)}}function ct(i,e,t=[],n){const r=new Map(Rr.filter(([,c])=>!t.includes(c))),s=new Set(vn);for(const c of t)s.delete(c);const a=Rt(i,"largestUnit",["auto",...s,...r.keys()],e);return a==="auto"&&n!==void 0?n:r.has(a)?r.get(a):a}function Qe(i,e,t=[]){const n=new Map(Rr.filter(([,a])=>!t.includes(a))),r=new Set(vn);for(const a of t)r.delete(a);const s=Rt(i,"smallestUnit",[...r,...n.keys()],e);return n.has(s)?n.get(s):s}function $n(i){const e=i.relativeTo;if(e===void 0)return e;let t,n,r,s,a,c,h,d,m,u,f,y,g="option",w=!1;if(he(e)){if(Y(e)||X(e))return e;if(W(e))return Jt(e);u=Rn(e);const p=pr(e,ve(u,["day","hour","microsecond","millisecond","minute","month","monthCode","nanosecond","second","year"])),v=le(null);v.overflow="constrain",{year:t,month:n,day:r,hour:s,minute:a,second:c,millisecond:h,microsecond:d,nanosecond:m}=er(u,p,v),y=e.offset,y===void 0&&(g="wall"),f=e.timeZone}else{let p,v;({year:t,month:n,day:r,hour:s,minute:a,second:c,millisecond:h,microsecond:d,nanosecond:m,calendar:u,ianaName:p,offset:y,z:v}=Yt(x(e))),p&&(f=p),v?g="exact":y||(g="wall"),u||(u=De()),u=Ze(u),w=!0}if(f){f=et(f);let p=0;return g==="option"&&(p=on(x(y))),Ne(vr(t,n,r,s,a,c,h,d,m,g,p,f,"compatible","reject",w),f,u)}return vt(t,n,r,u)}function mt(i,e){if(vn.indexOf(i)>vn.indexOf(e))throw new RangeError(`largestUnit ${i} cannot be smaller than smallestUnit ${e}`)}function ro(i,e,t,n,r,s,a,c,h,d){const m=new Map(Rr);for(const[u,f]of[["years",i],["months",e],["weeks",t],["days",n],["hours",r],["minutes",s],["seconds",a],["milliseconds",c],["microseconds",h],["nanoseconds",d]])if(f!==0)return m.get(u);return"nanosecond"}function pt(i,e){return vn.indexOf(i)>vn.indexOf(e)?e:i}function Ht(i,e){const t=i,n=e;let r=!1,s={};for(const a of n){const c=t[a];c!==void 0&&(r=!0,gr.has(a)?s[a]=gr.get(a)(c):s[a]=c)}return!!r&&s}function Fe(i,e){const t=i,n=e,r={};let s=!1;for(const a of n){const[c,h]=a;let d=t[c];if(d===void 0){if(a.length===1)throw new TypeError(`required property '${c}' missing or undefined`);d=h}else s=!0,gr.has(c)&&(d=gr.get(c)(d));r[c]=d}if(!s)throw new TypeError("no supported properties found");if(r.era===void 0!=(r.eraYear===void 0))throw new RangeError("properties 'era' and 'eraYear' must be provided together");return r}function oo(i,e){const t=[["day",void 0],["month",void 0],["monthCode",void 0],["year",void 0]];return e.forEach(n=>{t.some(([r])=>r===n)||t.push([n,void 0])}),Fe(i,t)}function pr(i,e){const t=[["day",void 0],["hour",0],["microsecond",0],["millisecond",0],["minute",0],["month",void 0],["monthCode",void 0],["nanosecond",0],["second",0],["year",void 0]];return e.forEach(n=>{t.some(([r])=>r===n)||t.push([n,void 0])}),Fe(i,t)}function Kt(i,e){const t=[["day",void 0],["month",void 0],["monthCode",void 0],["year",void 0]];return e.forEach(n=>{t.some(([r])=>r===n)||t.push([n,void 0])}),Fe(i,t)}function Eo(i){return Fe(i,[["hour",0],["microsecond",0],["millisecond",0],["minute",0],["nanosecond",0],["second",0]])}function rt(i,e){const t=[["month",void 0],["monthCode",void 0],["year",void 0]];return e.forEach(n=>{t.some(([r])=>r===n)||t.push([n,void 0])}),Fe(i,t)}function ae(i,e=le(null)){let t=i;if(he(t)){if(X(t))return t;if(Y(t)&&(t=lt(o(t,J),o(t,je),o(t,E))),W(t))return vt(o(t,R),o(t,$),o(t,I),o(t,E));const h=Rn(t);return Tt(h,oo(t,ve(h,["day","month","monthCode","year"])),e)}Le(e);const{year:n,month:r,day:s,calendar:a,z:c}=function(d){return Yt(d)}(x(t));if(c)throw new RangeError("Z designator not supported for PlainDate");return new(F("%Temporal.PlainDate%"))(n,r,s,a)}function er(i,e,t){let{hour:n,minute:r,second:s,millisecond:a,microsecond:c,nanosecond:h}=Eo(e);const d=Le(t),m=Tt(i,e,t),u=o(m,R),f=o(m,$),y=o(m,I);return{hour:n,minute:r,second:s,millisecond:a,microsecond:c,nanosecond:h}=Nn(n,r,s,a,c,h,d),{year:u,month:f,day:y,hour:n,minute:r,second:s,millisecond:a,microsecond:c,nanosecond:h}}function St(i,e=le(null)){let t,n,r,s,a,c,h,d,m,u;if(he(i)){if(W(i))return i;if(Y(i))return lt(o(i,J),o(i,je),o(i,E));if(X(i))return tt(o(i,R),o(i,$),o(i,I),0,0,0,0,0,0,o(i,E));u=Rn(i);const f=pr(i,ve(u,["day","hour","microsecond","millisecond","minute","month","monthCode","nanosecond","second","year"]));({year:t,month:n,day:r,hour:s,minute:a,second:c,millisecond:h,microsecond:d,nanosecond:m}=er(u,f,e))}else{let f;if(Le(e),{year:t,month:n,day:r,hour:s,minute:a,second:c,millisecond:h,microsecond:d,nanosecond:m,calendar:u,z:f}=function(g){return Yt(g)}(x(i)),f)throw new RangeError("Z designator not supported for PlainDateTime");Qi(t,n,r,s,a,c,h,d,m),u===void 0&&(u=De()),u=Ze(u)}return tt(t,n,r,s,a,c,h,d,m,u)}function fn(i){let e,t,n,r,s,a,c,h,d,m;if(he(i)){if(ge(i))return i;({years:e,months:t,weeks:n,days:r,hours:s,minutes:a,seconds:c,milliseconds:h,microseconds:d,nanoseconds:m}=Pi(i))}else({years:e,months:t,weeks:n,days:r,hours:s,minutes:a,seconds:c,milliseconds:h,microseconds:d,nanoseconds:m}=Ni(x(i)));return new(F("%Temporal.Duration%"))(e,t,n,r,s,a,c,h,d,m)}function Et(i){if(Ce(i))return i;if(Y(i))return new(F("%Temporal.Instant%"))(o(i,P));const e=ta(x(i));return new(F("%Temporal.Instant%"))(e)}function Ko(i,e=le(null)){if(he(i)){if(Ie(i))return i;let c,h;if(ke(i,E))c=o(i,E),h=!1;else{let m=i.calendar;h=m===void 0,m===void 0&&(m=De()),c=Ze(m)}const d=Kt(i,ve(c,["day","month","monthCode","year"]));return h&&d.month!==void 0&&d.monthCode===void 0&&d.year===void 0&&(d.year=1972),Tn(c,d,e)}Le(e);let{month:t,day:n,referenceISOYear:r,calendar:s}=Yi(x(i)),a=s;return a===void 0&&(a=De()),a=Ze(a),r===void 0?(Ot(1972,t,n),Un(t,n,a)):Tn(a,Un(t,n,a,r),le(null))}function _t(i,e="constrain"){let t,n,r,s,a,c,h,d=i;if(he(d)){if(we(d))return d;if(Y(d)&&(d=lt(o(d,J),o(d,je),o(d,E))),W(d))return new(F("%Temporal.PlainTime%"))(o(d,Z),o(d,j),o(d,A),o(d,S),o(d,q),o(d,U));if(h=Rn(d),x(h)!=="iso8601")throw new RangeError("PlainTime can only have iso8601 calendar");({hour:t,minute:n,second:r,millisecond:s,microsecond:a,nanosecond:c}=Eo(d)),{hour:t,minute:n,second:r,millisecond:s,microsecond:a,nanosecond:c}=Nn(t,n,r,s,a,c,e)}else if({hour:t,minute:n,second:r,millisecond:s,microsecond:a,nanosecond:c,calendar:h}=function(u){const f=Us.exec(u);let y,g,w,p,v,T,b;if(f){y=oe(f[1]),g=oe(f[2]||f[5]),w=oe(f[3]||f[6]),w===60&&(w=59);const D=(f[4]||f[7])+"000000000";p=oe(D.slice(0,3)),v=oe(D.slice(3,6)),T=oe(D.slice(6,9)),b=f[15]}else{let D,_;if({hasTime:_,hour:y,minute:g,second:w,millisecond:p,microsecond:v,nanosecond:T,calendar:b,z:D}=Yt(u),!_)throw new RangeError(`time is missing in string: ${u}`);if(D)throw new RangeError("Z designator not supported for PlainTime")}if(/[tT ][0-9][0-9]/.test(u))return{hour:y,minute:g,second:w,millisecond:p,microsecond:v,nanosecond:T,calendar:b};try{const{month:D,day:_}=Yi(u);Ot(1972,D,_)}catch{try{const{year:D,month:_}=Ii(u);Ot(D,_,1)}catch{return{hour:y,minute:g,second:w,millisecond:p,microsecond:v,nanosecond:T,calendar:b}}}throw new RangeError(`invalid ISO 8601 time-only string ${u}; may need a T prefix`)}(x(d)),Zr(t,n,r,s,a,c),h!==void 0&&h!=="iso8601")throw new RangeError("PlainTime can only have iso8601 calendar");return new(F("%Temporal.PlainTime%"))(t,n,r,s,a,c)}function ln(i,e=le(null)){if(he(i)){if(te(i))return i;const c=Rn(i);return zt(c,rt(i,ve(c,["month","monthCode","year"])),e)}Le(e);let{year:t,month:n,referenceISODay:r,calendar:s}=Ii(x(i)),a=s;return a===void 0&&(a=De()),a=Ze(a),r===void 0?(Ot(t,n,1),zn(t,n,a)):zt(a,zn(t,n,a,r),le(null))}function vr(i,e,t,n,r,s,a,c,h,d,m,u,f,y,g){const w=new(F("%Temporal.PlainDateTime%"))(i,e,t,n,r,s,a,c,h);if(d==="wall"||y==="ignore")return o(Je(u,w,f),P);if(d==="exact"||y==="use"){const v=Wt(i,e,t,n,r,s,a,c,h);if(v===null)throw new RangeError("ZonedDateTime outside of supported range");return l.subtract(v,l.BigInt(m))}const p=Tr(u,w);for(const v of p){const T=bt(u,v),b=l.toNumber(ot(l.BigInt(T),6e10,"halfExpand"));if(T===m||g&&b===m)return o(v,P)}if(y==="reject"){const v=Ro(m),T=Dt(u)?o(u,At):"time zone";throw new RangeError(`Offset ${v} is invalid for ${w.toString()} in ${T}`)}return o(Si(p,u,w,f),P)}function hn(i,e=le(null)){let t,n,r,s,a,c,h,d,m,u,f,y,g=!1,w="option";if(he(i)){if(Y(i))return i;y=Rn(i);const v=function(b,D){const _=[["day",void 0],["hour",0],["microsecond",0],["millisecond",0],["minute",0],["month",void 0],["monthCode",void 0],["nanosecond",0],["second",0],["year",void 0],["offset",void 0],["timeZone"]];return D.forEach(C=>{_.some(([M])=>M===C)||_.push([C,void 0])}),Fe(b,_)}(i,ve(y,["day","hour","microsecond","millisecond","minute","month","monthCode","nanosecond","second","year"]));({year:t,month:n,day:r,hour:s,minute:a,second:c,millisecond:h,microsecond:d,nanosecond:m}=er(y,v,e)),u=et(v.timeZone),f=v.offset,f===void 0?w="wall":f=x(f)}else{let v,T;if(Le(e),{year:t,month:n,day:r,hour:s,minute:a,second:c,millisecond:h,microsecond:d,nanosecond:m,ianaName:v,offset:f,z:T,calendar:y}=function(D){const _=Yt(D);if(!_.ianaName)throw new RangeError("Temporal.ZonedDateTime requires a time zone ID in brackets");return _}(x(i)),!v)throw new RangeError("time zone ID required in brackets");T?w="exact":f||(w="wall"),u=new(F("%Temporal.TimeZone%"))(v),y||(y=De()),y=Ze(y),g=!0}let p=0;return w==="option"&&(p=on(f)),Ne(vr(t,n,r,s,a,c,h,d,m,w,p,u,Sn(e),no(e,"reject"),g),u,y)}function Li(i,e,t,n,r){Ot(e,t,n),Xi(e,t,n),It(i),H(i,R,e),H(i,$,t),H(i,I,n),H(i,E,r),H(i,"slot-date-brand",!0)}function vt(i,e,t,n=De()){const r=F("%Temporal.PlainDate%"),s=le(r.prototype);return Li(s,i,e,t,n),s}function Fi(i,e,t,n,r,s,a,c,h,d,m){Qi(e,t,n,r,s,a,c,h,d),Ki(e,t,n,r,s,a,c,h,d),It(i),H(i,R,e),H(i,$,t),H(i,I,n),H(i,Z,r),H(i,j,s),H(i,A,a),H(i,S,c),H(i,q,h),H(i,U,d),H(i,E,m)}function tt(i,e,t,n,r,s,a,c,h,d=De()){const m=F("%Temporal.PlainDateTime%"),u=le(m.prototype);return Fi(u,i,e,t,n,r,s,a,c,h,d),u}function xi(i,e,t,n,r){Ot(r,e,t),Xi(r,e,t),It(i),H(i,$,e),H(i,I,t),H(i,R,r),H(i,E,n),H(i,"slot-month-day-brand",!0)}function Un(i,e,t=De(),n=1972){const r=F("%Temporal.PlainMonthDay%"),s=le(r.prototype);return xi(s,i,e,t,n),s}function Zi(i,e,t,n,r){Ot(e,t,r),function(a,c){Ae(a,-271821,275760),a===-271821?Ae(c,4,12):a===275760&&Ae(c,1,9)}(e,t),It(i),H(i,R,e),H(i,$,t),H(i,I,r),H(i,E,n),H(i,"slot-year-month-brand",!0)}function zn(i,e,t=De(),n=1){const r=F("%Temporal.PlainYearMonth%"),s=le(r.prototype);return Zi(s,i,e,t,n),s}function ji(i,e,t,n){Xt(e),It(i),H(i,P,e),H(i,J,t),H(i,E,n);const r=new(F("%Temporal.Instant%"))(o(i,P));H(i,je,r)}function Ne(i,e,t=De()){const n=F("%Temporal.ZonedDateTime%"),r=le(n.prototype);return ji(r,i,e,t),r}function De(){return new(F("%Temporal.Calendar%"))("iso8601")}function ve(i,e){let t=e;i.fields&&(t=i.fields(t));const n=[];for(const r of t){if(typeof r!="string")throw new TypeError("bad return from calendar.fields()");Di.call(n,r)}return n}function rn(i,e,t){const n=i.mergeFields;if(!n)return{...e,...t};const r=Reflect.apply(n,i,[e,t]);if(!he(r))throw new TypeError("bad return from calendar.mergeFields()");return r}function Xe(i,e,t,n,r){let s=r;s===void 0&&(s=i.dateAdd);const a=po(s,i,[e,t,n]);if(!X(a))throw new TypeError("invalid result");return a}function Mt(i,e,t,n,r){let s=r;s===void 0&&(s=i.dateUntil);const a=po(s,i,[e,t,n]);if(!ge(a))throw new TypeError("invalid result");return a}function $r(i,e){const t=i.year(e);if(t===void 0)throw new RangeError("calendar year result must be an integer");return ce(t)}function kr(i,e){const t=i.month(e);if(t===void 0)throw new RangeError("calendar month result must be a positive integer");return pn(t)}function tr(i,e){const t=i.monthCode(e);if(t===void 0)throw new RangeError("calendar monthCode result must be a string");return x(t)}function Ir(i,e){const t=i.day(e);if(t===void 0)throw new RangeError("calendar day result must be a positive integer");return pn(t)}function Yr(i,e){let t=i.era(e);return t!==void 0&&(t=x(t)),t}function Nr(i,e){let t=i.eraYear(e);return t!==void 0&&(t=ce(t)),t}function bo(i,e){return i.dayOfWeek(e)}function Do(i,e){return i.dayOfYear(e)}function _o(i,e){return i.weekOfYear(e)}function Co(i,e){return i.daysInWeek(e)}function yn(i,e){return i.daysInMonth(e)}function Pr(i,e){return i.daysInYear(e)}function Lr(i,e){return i.monthsInYear(e)}function Fr(i,e){return i.inLeapYear(e)}function Ze(i){let e=i;if(he(e)){if(ke(e,E))return o(e,E);if(!("calendar"in e)||(e=e.calendar,he(e)&&!("calendar"in e)))return e}const t=x(e),n=F("%Temporal.Calendar%");if(wi(t))return new n(t);let r;try{({calendar:r}=Yt(t))}catch{throw new RangeError(`Invalid calendar: ${t}`)}return r||(r="iso8601"),new n(r)}function Rn(i){if(ke(i,E))return o(i,E);const{calendar:e}=i;return e===void 0?De():Ze(e)}function nr(i,e){return i===e?!0:x(i)===x(e)}function Ai(i,e){if(i===e)return e;const t=x(i),n=x(e);if(t===n||t==="iso8601")return e;if(n==="iso8601")return i;throw new RangeError("irreconcilable calendars")}function Tt(i,e,t){const n=i.dateFromFields(e,t);if(!X(n))throw new TypeError("invalid result");return n}function zt(i,e,t){const n=i.yearMonthFromFields(e,t);if(!te(n))throw new TypeError("invalid result");return n}function Tn(i,e,t){const n=i.monthDayFromFields(e,t);if(!Ie(n))throw new TypeError("invalid result");return n}function et(i){let e=i;if(he(e)){if(Y(e))return o(e,J);if(!("timeZone"in e)||(e=e.timeZone,he(e)&&!("timeZone"in e)))return e}const t=ki(x(e));return new(F("%Temporal.TimeZone%"))(t)}function Wr(i,e){return i===e?!0:x(i)===x(e)}function Jt(i){return vt(o(i,R),o(i,$),o(i,I),o(i,E))}function Mo(i){return new(F("%Temporal.PlainTime%"))(o(i,Z),o(i,j),o(i,A),o(i,S),o(i,q),o(i,U))}function bt(i,e){let t=i.getOffsetNanosecondsFor;if(typeof t!="function")throw new TypeError("getOffsetNanosecondsFor not callable");const n=Reflect.apply(t,i,[e]);if(typeof n!="number")throw new TypeError("bad return from getOffsetNanosecondsFor");if(!Ri(n)||ee(n)>864e11)throw new RangeError("out-of-range return from getOffsetNanosecondsFor");return n}function io(i,e){return Ro(bt(i,e))}function lt(i,e,t){const n=o(e,P),r=bt(i,e);let{year:s,month:a,day:c,hour:h,minute:d,second:m,millisecond:u,microsecond:f,nanosecond:y}=Ui(n);return{year:s,month:a,day:c,hour:h,minute:d,second:m,millisecond:u,microsecond:f,nanosecond:y}=Hi(s,a,c,h,d,m,u,f,y+r),tt(s,a,c,h,d,m,u,f,y,t)}function Je(i,e,t){return Si(Tr(i,e),i,e,t)}function Si(i,e,t,n){const r=F("%Temporal.Instant%"),s=i.length;if(s===1)return i[0];if(s)switch(n){case"compatible":case"earlier":return i[0];case"later":return i[s-1];case"reject":throw new RangeError("multiple instants found")}const a=o(t,R),c=o(t,$),h=o(t,I),d=o(t,Z),m=o(t,j),u=o(t,A),f=o(t,S),y=o(t,q),g=o(t,U),w=Wt(a,c,h,d,m,u,f,y,g);if(w===null)throw new RangeError("DateTime outside of supported range");const p=new r(l.subtract(w,Gt)),v=new r(l.add(w,Gt)),T=bt(e,p),b=bt(e,v)-T;switch(n){case"earlier":{const D=o(t,E),_=F("%Temporal.PlainDateTime%"),C=_r(a,c,h,d,m,u,f,y,g,D,0,0,0,0,0,0,0,0,0,-b,void 0);return Tr(e,new _(C.year,C.month,C.day,C.hour,C.minute,C.second,C.millisecond,C.microsecond,C.nanosecond,D))[0]}case"compatible":case"later":{const D=o(t,E),_=F("%Temporal.PlainDateTime%"),C=_r(a,c,h,d,m,u,f,y,g,D,0,0,0,0,0,0,0,0,0,b,void 0),M=Tr(e,new _(C.year,C.month,C.day,C.hour,C.minute,C.second,C.millisecond,C.microsecond,C.nanosecond,D));return M[M.length-1]}case"reject":throw new RangeError("no such instant found")}}function Tr(i,e){const t=i.getPossibleInstantsFor(e),n=[];for(const r of t){if(!Ce(r))throw new TypeError("bad return from getPossibleInstantsFor");Di.call(n,r)}return n}function an(i){let e;return i<1e3||i>9999?e=(i<0?"-":"+")+`000000${ee(i)}`.slice(-6):e=`${i}`,e}function ue(i){return`00${i}`.slice(-2)}function xr(i,e,t,n,r){if(r==="minute")return"";const s=`:${ue(i)}`;let a,c=1e6*e+1e3*t+n;if(r==="auto"){if(c===0)return s;for(a=`${c}`.padStart(9,"0");a[a.length-1]==="0";)a=a.slice(0,-1)}else{if(r===0)return s;a=`${c}`.padStart(9,"0").slice(0,r)}return`${s}.${a}`}function Jo(i,e,t){let n=e;n===void 0&&(n=new(F("%Temporal.TimeZone%"))("UTC"));const r=lt(n,i,De()),s=an(o(r,R)),a=ue(o(r,$)),c=ue(o(r,I)),h=ue(o(r,Z)),d=ue(o(r,j)),m=xr(o(r,A),o(r,S),o(r,q),o(r,U),t);let u="Z";return e!==void 0&&(u=qi(bt(n,i))),`${s}-${a}-${c}T${h}:${d}${m}${u}`}function Hr(i,e="auto",t){function n(N){return N<=Qs?N.toString(10):l.BigInt(N).toString(10)}const r=o(i,Se),s=o(i,Oe),a=o(i,Ke),c=o(i,qe),h=o(i,Ue),d=o(i,ze);let m=o(i,Ge),u=o(i,We),f=o(i,He),y=o(i,Ve);const g=gt(r,s,a,c,h,d,m,u,f,y);if(t){const{unit:N,increment:K,roundingMode:Q}=t;({seconds:m,milliseconds:u,microseconds:f,nanoseconds:y}=ft(0,0,0,0,0,0,m,u,f,y,K,N,Q))}const w=[];r&&w.push(`${n(ee(r))}Y`),s&&w.push(`${n(ee(s))}M`),a&&w.push(`${n(ee(a))}W`),c&&w.push(`${n(ee(c))}D`);const p=[];h&&p.push(`${n(ee(h))}H`),d&&p.push(`${n(ee(d))}M`);const v=[];let T,b,D,_,C=En(0,0,0,m,u,f,y,0);({quotient:C,remainder:T}=Re(C,re)),{quotient:C,remainder:b}=Re(C,re),{quotient:_,remainder:D}=Re(C,re);const M=1e6*ee(l.toNumber(D))+1e3*ee(l.toNumber(b))+ee(l.toNumber(T));let k;if(e==="auto"){if(M!==0)for(k=`${M}`.padStart(9,"0");k[k.length-1]==="0";)k=k.slice(0,-1)}else e!==0&&(k=`${M}`.padStart(9,"0").slice(0,e));return k&&v.unshift(".",k),l.equal(_,be)&&!v.length&&e==="auto"||v.unshift(To(_).toString()),v.length&&p.push(`${v.join("")}S`),p.length&&p.unshift("T"),w.length||p.length?`${g<0?"-":""}P${w.join("")}${p.join("")}`:"PT0S"}function ei(i,e="auto"){return`${an(o(i,R))}-${ue(o(i,$))}-${ue(o(i,I))}${Xn(x(o(i,E)),e)}`}function ti(i,e,t="auto",n){let r=o(i,R),s=o(i,$),a=o(i,I),c=o(i,Z),h=o(i,j),d=o(i,A),m=o(i,S),u=o(i,q),f=o(i,U);if(n){const{unit:y,increment:g,roundingMode:w}=n;({year:r,month:s,day:a,hour:c,minute:h,second:d,millisecond:m,microsecond:u,nanosecond:f}=Io(r,s,a,c,h,d,m,u,f,g,y,w))}return`${an(r)}-${ue(s)}-${ue(a)}T${ue(c)}:${ue(h)}${xr(d,m,u,f,e)}${Xn(x(o(i,E)),t)}`}function ni(i,e="auto"){let t=`${ue(o(i,$))}-${ue(o(i,I))}`;const n=x(o(i,E));n!=="iso8601"&&(t=`${an(o(i,R))}-${t}`);const r=Xn(n,e);return r&&(t+=r),t}function ri(i,e="auto"){let t=`${an(o(i,R))}-${ue(o(i,$))}`;const n=x(o(i,E));n!=="iso8601"&&(t+=`-${ue(o(i,I))}`);const r=Xn(n,e);return r&&(t+=r),t}function oi(i,e,t="auto",n="auto",r="auto",s){let a=o(i,je);if(s){const{unit:m,increment:u,roundingMode:f}=s,y=Cr(o(i,P),u,m,f);a=new(F("%Temporal.Instant%"))(y)}const c=o(i,J),h=lt(c,a,De());let d=`${an(o(h,R))}-${ue(o(h,$))}-${ue(o(h,I))}T${ue(o(h,Z))}:${ue(o(h,j))}${xr(o(h,A),o(h,S),o(h,q),o(h,U),e)}`;return r!=="never"&&(d+=qi(bt(c,a))),n!=="never"&&(d+=`[${c}]`),d+=Xn(x(o(i,E)),t),d}function mn(i){return es.test(Bn(i))}function on(i){const e=es.exec(Bn(i));if(!e)throw new RangeError(`invalid time zone offset: ${i}`);return(e[1]==="-"||e[1]==="\u2212"?-1:1)*(1e9*(60*(60*+e[2]+ +(e[3]||0))+ +(e[4]||0))+ +((e[5]||0)+"000000000").slice(0,9))}function Oo(i){return mn(i)?Ro(on(i)):$i(Bn(i)).resolvedOptions().timeZone}function Nt(i,e){const{year:t,month:n,day:r,hour:s,minute:a,second:c,millisecond:h,microsecond:d,nanosecond:m}=zi(i,e),u=Wt(t,n,r,s,a,c,h,d,m);if(u===null)throw new RangeError("Date outside of supported range");return l.toNumber(l.subtract(u,i))}function Ro(i){const e=i<0?"-":"+",t=ee(i),n=t%1e9,r=$e(t/1e9)%60,s=$e(t/6e10)%60,a=ue($e(t/36e11)),c=ue(s),h=ue(r);let d="";if(n){let m=`${n}`.padStart(9,"0");for(;m[m.length-1]==="0";)m=m.slice(0,-1);d=`:${h}.${m}`}else r&&(d=`:${h}`);return`${e}${a}:${c}${d}`}function qi(i){let e=l.toNumber(ot(l.BigInt(i),6e10,"halfExpand"));const t=e<0?"-":"+";e=ee(e);const n=e/6e10%60;return`${t}${ue($e(e/36e11))}:${ue(n)}`}function Wt(i,e,t,n,r,s,a,c,h){const d=new Date;d.setUTCHours(n,r,s,a),d.setUTCFullYear(i,e-1,t);const m=d.getTime();if(Vn(m))return null;let u=l.multiply(l.BigInt(m),dt);return u=l.add(u,l.multiply(l.BigInt(c),re)),u=l.add(u,l.BigInt(h)),l.lessThan(u,Zn)||l.greaterThan(u,jn)?null:u}function Ui(i){const{quotient:e,remainder:t}=Re(i,dt);let n=l.toNumber(e),r=l.toNumber(t);r<0&&(r+=1e6,n-=1);const s=$e(r/1e3)%1e3,a=r%1e3,c=new Date(n);return{epochMilliseconds:n,year:c.getUTCFullYear(),month:c.getUTCMonth()+1,day:c.getUTCDate(),hour:c.getUTCHours(),minute:c.getUTCMinutes(),second:c.getUTCSeconds(),millisecond:c.getUTCMilliseconds(),microsecond:s,nanosecond:a}}function zi(i,e){const{epochMilliseconds:t,millisecond:n,microsecond:r,nanosecond:s}=Ui(i),{year:a,month:c,day:h,hour:d,minute:m,second:u}=function(y,g){const w=$i(y);return function(v){const T=v.split(/[^\w]+/);if(T.length!==7)throw new RangeError(`expected 7 parts in "${v}`);const b=+T[0],D=+T[1];let _=+T[2];const C=T[3].toUpperCase();if(C==="B"||C==="BC")_=1-_;else if(C!=="A"&&C!=="AD")throw new RangeError(`Unknown era ${C} in "${v}`);let M=+T[4];M===24&&(M=0);const k=+T[5],N=+T[6];if(!(Pe(_)&&Pe(b)&&Pe(D)&&Pe(M)&&Pe(k)&&Pe(N)))throw new RangeError(`Invalid number in "${v}`);return{year:_,month:b,day:D,hour:M,minute:k,second:N}}(w.format(new Date(g)))}(e,t);return Hi(a,c,h,d,m,u,n,r,s)}function ii(i,e){return l.lessThan(i,e)?e:i}function Gi(){return l.add(No(),ea)}function Wi(i,e){const t=Gi(),n=l.greaterThan(i,t),r=n?l.subtract(i,Mi):Ci;let s=l.subtract(i,vo);const a=Nt(s,e);let c=s,h=a;for(;a===h&&l.greaterThan(s,r);)c=l.subtract(s,Oi),h=Nt(c,e),a===h&&(s=c);return a===h?n?Wi(l.subtract(t,Gt),e):null:ts(d=>Nt(d,e),c,s,h,a)}function Ut(i){return i===void 0?!1:i%4==0&&(i%100!=0||i%400==0)}function jt(i,e){return{standard:[31,28,31,30,31,30,31,31,30,31,30,31],leapyear:[31,29,31,30,31,30,31,31,30,31,30,31]}[Ut(i)?"leapyear":"standard"][e-1]}function Vr(i,e,t){const n=e+(e<3?10:-2),r=i-(e<3?1:0),s=$e(r/100),a=r-100*s,c=(t+$e(2.6*n-.2)+(a+$e(a/4))+($e(s/4)-2*s))%7;return c+(c<=0?7:0)}function Er(i,e,t){let n=t;for(let r=e-1;r>0;r--)n+=jt(i,r);return n}function gt(i,e,t,n,r,s,a,c,h,d){for(const m of[i,e,t,n,r,s,a,c,h,d])if(m!==0)return m<0?-1:1;return 0}function dr(i,e){let t=i,n=e;if(!Pe(t)||!Pe(n))throw new RangeError("infinity is out of range");return n-=1,t+=$e(n/12),n%=12,n<0&&(n+=12),n+=1,{year:t,month:n}}function Gn(i,e,t){let n=i,r=e,s=t;if(!Pe(s))throw new RangeError("infinity is out of range");({year:n,month:r}=dr(n,r));let a=0,c=r>2?n:n-1;for(;a=Ut(c)?366:365,s<-a;)n-=1,c-=1,s+=a;for(c+=1;a=Ut(c)?366:365,s>a;)n+=1,c+=1,s-=a;for(;s<1;)({year:n,month:r}=dr(n,r-1)),s+=jt(n,r);for(;s>jt(n,r);)s-=jt(n,r),{year:n,month:r}=dr(n,r+1);return{year:n,month:r,day:s}}function Hi(i,e,t,n,r,s,a,c,h){const{deltaDays:d,hour:m,minute:u,second:f,millisecond:y,microsecond:g,nanosecond:w}=Pt(n,r,s,a,c,h),{year:p,month:v,day:T}=Gn(i,e,t+d);return{year:p,month:v,day:T,hour:m,minute:u,second:f,millisecond:y,microsecond:g,nanosecond:w}}function Pt(i,e,t,n,r,s){let a=i,c=e,h=t,d=n,m=r,u=s;if(!(Pe(a)&&Pe(c)&&Pe(h)&&Pe(d)&&Pe(m)&&Pe(u)))throw new RangeError("infinity is out of range");m+=$e(u/1e3),u=dn(u,1e3),d+=$e(m/1e3),m=dn(m,1e3),h+=$e(d/1e3),d=dn(d,1e3),c+=$e(h/60),h=dn(h,60),a+=$e(c/60),c=dn(c,60);const f=$e(a/24);return a=dn(a,24),{deltaDays:f,hour:a,minute:c,second:h,millisecond:d,microsecond:m,nanosecond:u}}function En(i,e,t,n,r,s,a,c){const h=l.BigInt(i);let d=l.BigInt(a);i!==0&&(d=l.subtract(l.BigInt(a),l.BigInt(c)));const m=l.add(l.BigInt(e),l.multiply(h,l.BigInt(24))),u=l.add(l.BigInt(t),l.multiply(m,Qt)),f=l.add(l.BigInt(n),l.multiply(u,Qt)),y=l.add(l.BigInt(r),l.multiply(f,re)),g=l.add(l.BigInt(s),l.multiply(y,re));return l.add(l.BigInt(d),l.multiply(g,re))}function $o(i,e){const t=F("%Temporal.Instant%"),n=xn(l.toNumber(i));let r=l.BigInt(i),s=864e11;if(n===0)return{days:0,nanoseconds:be,dayLengthNs:s};if(!Y(e)){let T;return{quotient:T,remainder:r}=Re(r,l.BigInt(s)),{days:l.toNumber(T),nanoseconds:r,dayLengthNs:s}}const a=o(e,P),c=o(e,je),h=l.add(a,r),d=new t(h),m=o(e,J),u=o(e,E),f=lt(m,c,u),y=lt(m,d,u);let{days:g}=br(o(f,R),o(f,$),o(f,I),o(f,Z),o(f,j),o(f,A),o(f,S),o(f,q),o(f,U),o(y,R),o(y,$),o(y,I),o(y,Z),o(y,j),o(y,A),o(y,S),o(y,q),o(y,U),u,"day"),w=at(c,m,u,0,0,0,g,0,0,0,0,0,0);if(n===1)for(;g>0&&l.greaterThan(w,h);)--g,w=at(c,m,u,0,0,0,g,0,0,0,0,0,0);r=l.subtract(h,w);let p=!1,v=new t(w);do{const T=at(v,m,u,0,0,0,n,0,0,0,0,0,0),b=o(v,P);s=l.toNumber(l.subtract(T,b)),p=l.greaterThan(l.multiply(l.subtract(r,l.BigInt(s)),l.BigInt(n)),be),p&&(r=l.subtract(r,l.BigInt(s)),v=new t(T),g+=n)}while(p);return{days:g,nanoseconds:r,dayLengthNs:ee(s)}}function xe(i,e,t,n,r,s,a,c,h){let d,m,u,f,y,g,w=i;if(Y(h)){const v=at(o(h,je),o(h,J),o(h,E),0,0,0,w,e,t,n,r,s,a),T=o(h,P);d=l.subtract(v,T)}else d=En(w,e,t,n,r,s,a,0);c==="year"||c==="month"||c==="week"||c==="day"?{days:w,nanoseconds:d}=$o(d,h):w=0;const p=l.lessThan(d,be)?-1:1;switch(d=To(d),m=u=f=y=g=be,c){case"year":case"month":case"week":case"day":case"hour":({quotient:m,remainder:d}=Re(d,re)),{quotient:u,remainder:m}=Re(m,re),{quotient:f,remainder:u}=Re(u,re),{quotient:y,remainder:f}=Re(f,Qt),{quotient:g,remainder:y}=Re(y,Qt);break;case"minute":({quotient:m,remainder:d}=Re(d,re)),{quotient:u,remainder:m}=Re(m,re),{quotient:f,remainder:u}=Re(u,re),{quotient:y,remainder:f}=Re(f,Qt);break;case"second":({quotient:m,remainder:d}=Re(d,re)),{quotient:u,remainder:m}=Re(m,re),{quotient:f,remainder:u}=Re(u,re);break;case"millisecond":({quotient:m,remainder:d}=Re(d,re)),{quotient:u,remainder:m}=Re(m,re);break;case"microsecond":({quotient:m,remainder:d}=Re(d,re));break;case"nanosecond":break;default:throw new Error("assert not reached")}return{days:w,hours:l.toNumber(g)*p,minutes:l.toNumber(y)*p,seconds:l.toNumber(f)*p,milliseconds:l.toNumber(u)*p,microseconds:l.toNumber(m)*p,nanoseconds:l.toNumber(d)*p}}function ar(i,e,t,n,r,s){let a=i,c=e,h=t,d=n;const m=F("%Temporal.Duration%"),u=gt(a,c,h,d,0,0,0,0,0,0);let f,y;s&&(y=ae(s),f=o(y,E));const g=new m(u),w=new m(0,u),p=new m(0,0,u);switch(r){case"year":break;case"month":{if(!f)throw new RangeError("a starting point is required for months balancing");const v=f.dateAdd,T=f.dateUntil;let b=y;for(;ee(a)>0;){const D=Xe(f,b,g,le(null),v),_=le(null);_.largestUnit="month";const C=o(Mt(f,b,D,_,T),Oe);b=D,c+=C,a-=u}}break;case"week":if(!f)throw new RangeError("a starting point is required for weeks balancing");for(;ee(a)>0;){let v;({relativeTo:y,days:v}=Be(f,y,g)),d+=v,a-=u}for(;ee(c)>0;){let v;({relativeTo:y,days:v}=Be(f,y,w)),d+=v,c-=u}break;default:for(;ee(a)>0;){if(!f)throw new RangeError("a starting point is required for balancing calendar units");let v;({relativeTo:y,days:v}=Be(f,y,g)),d+=v,a-=u}for(;ee(c)>0;){if(!f)throw new RangeError("a starting point is required for balancing calendar units");let v;({relativeTo:y,days:v}=Be(f,y,w)),d+=v,c-=u}for(;ee(h)>0;){if(!f)throw new RangeError("a starting point is required for balancing calendar units");let v;({relativeTo:y,days:v}=Be(f,y,p)),d+=v,h-=u}}return{years:a,months:c,weeks:h,days:d}}function si(i,e,t,n,r,s,a,c,h,d,m){if(Y(i)){const u=o(i,je),f=o(i,J),y=o(i,E),g=bt(f,u),w=at(u,f,y,e,t,n,r,s,a,c,h,d,m);return bt(f,new(F("%Temporal.Instant%"))(w))-g}return 0}function Vi(i){return new(F("%Temporal.Duration%"))(-o(i,Se),-o(i,Oe),-o(i,Ke),-o(i,qe),-o(i,Ue),-o(i,ze),-o(i,Ge),-o(i,We),-o(i,He),-o(i,Ve))}function it(i,e,t){return Vs(t,Bs(e,i))}function Bi(i,e,t){const n=it(e,1,12);return{year:i,month:n,day:it(t,1,jt(i,n))}}function Ae(i,e,t){if(i<e||i>t)throw new RangeError(`value out of range: ${e} <= ${i} <= ${t}`)}function Ot(i,e,t){Ae(e,1,12),Ae(t,1,jt(i,e))}function Xi(i,e,t){Ki(i,e,t,12,0,0,0,0,0)}function Zr(i,e,t,n,r,s){Ae(i,0,23),Ae(e,0,59),Ae(t,0,59),Ae(n,0,999),Ae(r,0,999),Ae(s,0,999)}function Qi(i,e,t,n,r,s,a,c,h){Ot(i,e,t),Zr(n,r,s,a,c,h)}function Ki(i,e,t,n,r,s,a,c,h){if(Ae(i,-271821,275760),i===-271821&&Wt(i,e,t+1,n,r,s,a,c,h-1)==null||i===275760&&Wt(i,e,t-1,n,r,s,a,c,h+1)==null)throw new RangeError("DateTime outside of supported range")}function Xt(i){if(l.lessThan(i,Zn)||l.greaterThan(i,jn))throw new RangeError("Instant outside of supported range")}function Ji(i,e,t,n,r,s,a,c,h,d){const m=gt(i,e,t,n,r,s,a,c,h,d);for(const u of[i,e,t,n,r,s,a,c,h,d]){if(!Pe(u))throw new RangeError("infinite values not allowed as duration fields");const f=xn(u);if(f!==0&&f!==m)throw new RangeError("mixed-sign values not allowed as duration fields")}}function ko(i,e,t,n,r,s,a){switch(a){case"year":case"month":{const c=-Lt(i,e,t,n,r,s);if(c===0)return{years:0,months:0,weeks:0,days:0};const h={year:i,month:e,day:t},d={year:n,month:r,day:s};let m=d.year-h.year,u=en(i,e,t,m,0,0,0,"constrain"),f=-Lt(u.year,u.month,u.day,n,r,s);if(f===0)return a==="year"?{years:m,months:0,weeks:0,days:0}:{years:0,months:12*m,weeks:0,days:0};let y=d.month-h.month;if(f!==c&&(m-=c,y+=12*c),u=en(i,e,t,m,y,0,0,"constrain"),f=-Lt(u.year,u.month,u.day,n,r,s),f===0)return a==="year"?{years:m,months:y,weeks:0,days:0}:{years:0,months:y+12*m,weeks:0,days:0};f!==c&&(y-=c,y===-c&&(m-=c,y=11*c),u=en(i,e,t,m,y,0,0,"constrain"),f=-Lt(i,e,t,u.year,u.month,u.day));let g=0;return g=u.month===d.month?d.day-u.day:c<0?-u.day-(jt(d.year,d.month)-d.day):d.day+(jt(u.year,u.month)-u.day),a==="month"&&(y+=12*m,m=0),{years:m,months:y,weeks:0,days:g}}case"week":case"day":{let c,h,d;Lt(i,e,t,n,r,s)<0?(h={year:i,month:e,day:t},c={year:n,month:r,day:s},d=1):(h={year:n,month:r,day:s},c={year:i,month:e,day:t},d=-1);let m=Er(c.year,c.month,c.day)-Er(h.year,h.month,h.day);for(let f=h.year;f<c.year;++f)m+=Ut(f)?366:365;let u=0;return a==="week"&&(u=$e(m/7),m%=7),u*=d,m*=d,{years:0,months:0,weeks:u,days:m}}default:throw new Error("assert not reached")}}function so(i,e,t,n,r,s,a,c,h,d,m,u){let f=a-i,y=c-e,g=h-t,w=d-n,p=m-r,v=u-s;const T=gt(0,0,0,0,f,y,g,w,p,v);f*=T,y*=T,g*=T,w*=T,p*=T,v*=T;let b=0;return{deltaDays:b,hour:f,minute:y,second:g,millisecond:w,microsecond:p,nanosecond:v}=Pt(f,y,g,w,p,v),b*=T,f*=T,y*=T,g*=T,w*=T,p*=T,v*=T,{deltaDays:b,hours:f,minutes:y,seconds:g,milliseconds:w,microseconds:p,nanoseconds:v}}function Wn(i,e,t,n,r){const s=l.subtract(e,i),a=l.remainder(s,l.BigInt(864e11)),c=l.subtract(s,a),h=ot(a,Po[n]*t,r),d=l.add(c,h),m=l.toNumber(l.remainder(d,re)),u=l.toNumber(l.remainder(l.divide(d,re),re)),f=l.toNumber(l.remainder(l.divide(d,dt),re));return{seconds:l.toNumber(l.divide(d,Zt)),milliseconds:f,microseconds:u,nanoseconds:m}}function br(i,e,t,n,r,s,a,c,h,d,m,u,f,y,g,w,p,v,T,b,D=le(null)){let _=i,C=e,M=t,{deltaDays:k,hours:N,minutes:K,seconds:Q,milliseconds:V,microseconds:L,nanoseconds:G}=so(n,r,s,a,c,h,f,y,g,w,p,v);const O=gt(0,0,0,k,N,K,Q,V,L,G);({year:_,month:C,day:M}=Gn(_,C,M+k)),Lt(d,m,u,_,C,M)===-O&&({year:_,month:C,day:M}=Gn(_,C,M-O),{hours:N,minutes:K,seconds:Q,milliseconds:V,microseconds:L,nanoseconds:G}=xe(-O,N,K,Q,V,L,G,b));const B=vt(_,C,M,T),ie=vt(d,m,u,T),ne={...D,largestUnit:pt("day",b)};let{years:se,months:ye,weeks:nt,days:yt}=Mt(T,B,ie,ne);return{days:yt,hours:N,minutes:K,seconds:Q,milliseconds:V,microseconds:L,nanoseconds:G}=xe(yt,N,K,Q,V,L,G,b),{years:se,months:ye,weeks:nt,days:yt,hours:N,minutes:K,seconds:Q,milliseconds:V,microseconds:L,nanoseconds:G}}function ao(i,e,t,n,r,s){const a=l.subtract(e,i);if(l.equal(a,be))return{years:0,months:0,weeks:0,days:0,hours:0,minutes:0,seconds:0,milliseconds:0,microseconds:0,nanoseconds:0};const c=F("%Temporal.Instant%"),h=new c(i),d=new c(e),m=lt(t,h,n),u=lt(t,d,n);let{years:f,months:y,weeks:g,days:w}=br(o(m,R),o(m,$),o(m,I),o(m,Z),o(m,j),o(m,A),o(m,S),o(m,q),o(m,U),o(u,R),o(u,$),o(u,I),o(u,Z),o(u,j),o(u,A),o(u,S),o(u,q),o(u,U),n,r,s);const p=at(h,t,n,f,y,g,0,0,0,0,0,0,0);let v=l.subtract(e,p);const T=Ne(p,t,n);({nanoseconds:v,days:w}=$o(v,T));const{hours:b,minutes:D,seconds:_,milliseconds:C,microseconds:M,nanoseconds:k}=xe(0,0,0,0,0,0,l.toNumber(v),"hour");return{years:f,months:y,weeks:g,days:w,hours:b,minutes:D,seconds:_,milliseconds:C,microseconds:M,nanoseconds:k}}function en(i,e,t,n,r,s,a,c){let h=i,d=e,m=t,u=s,f=a;return h+=n,d+=r,{year:h,month:d}=dr(h,d),{year:h,month:d,day:m}=wr(h,d,m,c),f+=7*u,m+=f,{year:h,month:d,day:m}=Gn(h,d,m),{year:h,month:d,day:m}}function co(i,e,t,n,r,s,a,c,h,d,m,u){let f=i,y=e,g=t,w=n,p=r,v=s;f+=a,y+=c,g+=h,w+=d,p+=m,v+=u;let T=0;return{deltaDays:T,hour:f,minute:y,second:g,millisecond:w,microsecond:p,nanosecond:v}=Pt(f,y,g,w,p,v),{deltaDays:T,hour:f,minute:y,second:g,millisecond:w,microsecond:p,nanosecond:v}}function lo(i,e,t,n,r,s,a,c,h,d,m,u,f,y,g,w,p,v,T,b,D){const _=pt(ro(i,e,t,n,r,s,a,c,h,d),ro(m,u,f,y,g,w,p,v,T,b));let C,M,k,N,K,Q,V,L,G,O;if(D)if(X(D)){const B=F("%Temporal.Duration%"),ie=o(D,E),ne=new B(i,e,t,n,0,0,0,0,0,0),se=new B(m,u,f,y,0,0,0,0,0,0),ye=ie.dateAdd,nt=Xe(ie,D,ne,le(null),ye),yt=Xe(ie,nt,se,le(null),ye),pe=pt("day",_),_e=le(null);_e.largestUnit=pe,{years:C,months:M,weeks:k,days:N}=Mt(ie,D,yt,_e),{days:N,hours:K,minutes:Q,seconds:V,milliseconds:L,microseconds:G,nanoseconds:O}=xe(N,r+g,s+w,a+p,c+v,h+T,d+b,_)}else{const B=F("%Temporal.Instant%"),ie=o(D,J),ne=o(D,E),se=at(o(D,je),ie,ne,i,e,t,n,r,s,a,c,h,d),ye=at(new B(se),ie,ne,m,u,f,y,g,w,p,v,T,b);_!=="year"&&_!=="month"&&_!=="week"&&_!=="day"?(C=0,M=0,k=0,N=0,{seconds:V,milliseconds:L,microseconds:G,nanoseconds:O}=Wn(o(D,P),ye,1,"nanosecond","halfExpand"),{hours:K,minutes:Q,seconds:V,milliseconds:L,microseconds:G,nanoseconds:O}=xe(0,0,0,V,L,G,O,_)):{years:C,months:M,weeks:k,days:N,hours:K,minutes:Q,seconds:V,milliseconds:L,microseconds:G,nanoseconds:O}=ao(o(D,P),ye,ie,ne,_)}else{if(_==="year"||_==="month"||_==="week")throw new RangeError("relativeTo is required for years, months, or weeks arithmetic");C=M=k=0,{days:N,hours:K,minutes:Q,seconds:V,milliseconds:L,microseconds:G,nanoseconds:O}=xe(n+y,r+g,s+w,a+p,c+v,h+T,d+b,_)}return Ji(C,M,k,N,K,Q,V,L,G,O),{years:C,months:M,weeks:k,days:N,hours:K,minutes:Q,seconds:V,milliseconds:L,microseconds:G,nanoseconds:O}}function Dr(i,e,t,n,r,s,a){let c=be;c=l.add(c,l.BigInt(a)),c=l.add(c,l.multiply(l.BigInt(s),re)),c=l.add(c,l.multiply(l.BigInt(r),dt)),c=l.add(c,l.multiply(l.BigInt(n),Zt)),c=l.add(c,l.multiply(l.BigInt(t),l.BigInt(6e10))),c=l.add(c,l.multiply(l.BigInt(e),l.BigInt(36e11)));const h=l.add(i,c);return Xt(h),h}function _r(i,e,t,n,r,s,a,c,h,d,m,u,f,y,g,w,p,v,T,b,D){let _=y,{deltaDays:C,hour:M,minute:k,second:N,millisecond:K,microsecond:Q,nanosecond:V}=co(n,r,s,a,c,h,g,w,p,v,T,b);_+=C;const L=F("%Temporal.Duration%"),G=Xe(d,vt(i,e,t,d),new L(m,u,f,_,0,0,0,0,0,0),D);return{year:o(G,R),month:o(G,$),day:o(G,I),hour:M,minute:k,second:N,millisecond:K,microsecond:Q,nanosecond:V}}function at(i,e,t,n,r,s,a,c,h,d,m,u,f,y){const g=F("%Temporal.Duration%");if(gt(n,r,s,a,0,0,0,0,0,0)===0)return Dr(o(i,P),c,h,d,m,u,f);const w=lt(e,i,t),p=Xe(t,vt(o(w,R),o(w,$),o(w,I),t),new g(n,r,s,a,0,0,0,0,0,0),y),v=tt(o(p,R),o(p,$),o(p,I),o(w,Z),o(w,j),o(w,A),o(w,S),o(w,q),o(w,U),t);return Dr(o(Je(e,v,"compatible"),P),c,h,d,m,u,f)}function ot(i,e,t){if(e===1)return i;let{quotient:n,remainder:r}=Re(i,l.BigInt(e));if(l.equal(r,be))return i;const s=l.lessThan(r,be)?-1:1;switch(t){case"ceil":s>0&&(n=l.add(n,l.BigInt(s)));break;case"floor":s<0&&(n=l.add(n,l.BigInt(s)));break;case"trunc":break;case"halfExpand":l.toNumber(To(l.multiply(r,l.BigInt(2))))>=e&&(n=l.add(n,l.BigInt(s)))}return l.multiply(n,l.BigInt(e))}function Cr(i,e,t,n){let r=l.remainder(i,l.BigInt(864e11));l.lessThan(r,be)&&(r=l.add(r,l.BigInt(864e11)));const s=l.subtract(i,r),a=ot(r,Po[t]*e,n);return l.add(s,a)}function Io(i,e,t,n,r,s,a,c,h,d,m,u,f=864e11){const{deltaDays:y,hour:g,minute:w,second:p,millisecond:v,microsecond:T,nanosecond:b}=Yo(n,r,s,a,c,h,d,m,u,f),{year:D,month:_,day:C}=Gn(i,e,t+y);return{year:D,month:_,day:C,hour:g,minute:w,second:p,millisecond:v,microsecond:T,nanosecond:b}}function Yo(i,e,t,n,r,s,a,c,h,d=864e11){let m=be;switch(c){case"day":case"hour":m=l.BigInt(i);case"minute":m=l.add(l.multiply(m,Qt),l.BigInt(e));case"second":m=l.add(l.multiply(m,Qt),l.BigInt(t));case"millisecond":m=l.add(l.multiply(m,re),l.BigInt(n));case"microsecond":m=l.add(l.multiply(m,re),l.BigInt(r));case"nanosecond":m=l.add(l.multiply(m,re),l.BigInt(s))}const u=c==="day"?d:Po[c],f=ot(m,u*a,h),y=l.toNumber(l.divide(f,l.BigInt(u)));switch(c){case"day":return{deltaDays:y,hour:0,minute:0,second:0,millisecond:0,microsecond:0,nanosecond:0};case"hour":return Pt(y,0,0,0,0,0);case"minute":return Pt(i,y,0,0,0,0);case"second":return Pt(i,e,y,0,0,0);case"millisecond":return Pt(i,e,t,y,0,0);case"microsecond":return Pt(i,e,t,n,y,0);case"nanosecond":return Pt(i,e,t,n,r,y);default:throw new Error(`Invalid unit ${c}`)}}function ur(i,e){return ko(o(i,R),o(i,$),o(i,I),o(e,R),o(e,$),o(e,I),"day").days}function Be(i,e,t){const n=Xe(i,e,t,le(null));return{relativeTo:n,days:ur(e,n)}}function ho(i,e,t,n,r){const s=o(i,J),a=o(i,E);return Ne(at(o(i,je),s,a,e,t,n,r,0,0,0,0,0,0),s,a)}function uo(i,e,t,n,r,s,a,c,h,d,m,u,f,y){let g=i,w=e,p=t,v=n,T=r,b=s,D=a,_=c,C=h,M=d;if(!Y(y)||u==="year"||u==="month"||u==="week"||u==="day"||u==="nanosecond"&&m===1)return{years:g,months:w,weeks:p,days:v,hours:T,minutes:b,seconds:D,milliseconds:_,microseconds:C,nanoseconds:M};let k=En(0,T,b,D,_,C,M,0);const N=xn(l.toNumber(k)),K=o(y,J),Q=o(y,E),V=at(o(y,je),K,Q,g,w,p,v,0,0,0,0,0,0),L=at(new(F("%Temporal.Instant%"))(V),K,Q,0,0,0,N,0,0,0,0,0,0),G=l.subtract(L,V);return l.greaterThanOrEqual(l.multiply(l.subtract(k,G),l.BigInt(N)),be)&&({years:g,months:w,weeks:p,days:v}=lo(g,w,p,v,0,0,0,0,0,0,0,0,0,N,0,0,0,0,0,0,y),k=Cr(l.subtract(k,G),m,u,f),{hours:T,minutes:b,seconds:D,milliseconds:_,microseconds:C,nanoseconds:M}=xe(0,0,0,0,0,0,l.toNumber(k),"hour")),{years:g,months:w,weeks:p,days:v,hours:T,minutes:b,seconds:D,milliseconds:_,microseconds:C,nanoseconds:M}}function ft(i,e,t,n,r,s,a,c,h,d,m,u,f,y){let g=i,w=e,p=t,v=n,T=r,b=s,D=a,_=c,C=h,M=l.BigInt(d);const k=F("%Temporal.Duration%");let N,K,Q,V,L=y;if(L){if(Y(L))K=L,L=ae(L);else if(!X(L))throw new TypeError("starting point must be PlainDate or ZonedDateTime");N=o(L,E)}if(u==="year"||u==="month"||u==="week"||u==="day"){let G,O,B;M=En(0,T,b,D,_,C,d,0),K&&(G=ho(K,g,w,p,v)),{days:O,nanoseconds:M,dayLengthNs:B}=$o(M,G),Q=l.BigInt(B),v+=O,T=b=D=_=C=0}switch(u){case"year":{if(!N)throw new RangeError("A starting point is required for years rounding");const G=new k(g),O=N.dateAdd,B=Xe(N,L,G,le(null),O),ie=Xe(N,L,new k(g,w,p),le(null),O);L=B,v+=ur(B,ie);const ne=Xe(N,L,{days:v},le(null),O),se=le(null);se.largestUnit="year";const ye=Mt(N,L,ne,se).years;g+=ye;const nt=L;L=Xe(N,L,{years:ye},le(null),O),v-=ur(nt,L);const yt=new k(v<0?-1:1);let{days:pe}=Be(N,L,yt);pe=ee(pe);const _e=l.multiply(l.BigInt(pe),Q);M=l.add(l.add(l.multiply(_e,l.BigInt(g)),l.multiply(l.BigInt(v),Q)),M);const cn=ot(M,l.toNumber(l.multiply(_e,l.BigInt(m))),f);V=l.toNumber(M)/l.toNumber(_e),g=l.toNumber(l.divide(cn,_e)),M=be,w=p=v=0;break}case"month":{if(!N)throw new RangeError("A starting point is required for months rounding");const G=new k(g,w),O=N.dateAdd,B=Xe(N,L,G,le(null),O),ie=Xe(N,L,new k(g,w,p),le(null),O);L=B,v+=ur(B,ie);const ne=xn(v),se=new k(0,v<0?-1:1);let ye;for({relativeTo:L,days:ye}=Be(N,L,se);ee(v)>=ee(ye);)w+=ne,v-=ye,{relativeTo:L,days:ye}=Be(N,L,se);ye=ee(ye);const nt=l.multiply(l.BigInt(ye),Q);M=l.add(l.add(l.multiply(nt,l.BigInt(w)),l.multiply(l.BigInt(v),Q)),M);const yt=ot(M,l.toNumber(l.multiply(nt,l.BigInt(m))),f);V=l.toNumber(M)/l.toNumber(nt),w=l.toNumber(l.divide(yt,nt)),M=be,p=v=0;break}case"week":{if(!N)throw new RangeError("A starting point is required for weeks rounding");const G=xn(v),O=new k(0,0,v<0?-1:1);let B;for({relativeTo:L,days:B}=Be(N,L,O);ee(v)>=ee(B);)p+=G,v-=B,{relativeTo:L,days:B}=Be(N,L,O);B=ee(B);const ie=l.multiply(l.BigInt(B),Q);M=l.add(l.add(l.multiply(ie,l.BigInt(p)),l.multiply(l.BigInt(v),Q)),M);const ne=ot(M,l.toNumber(l.multiply(ie,l.BigInt(m))),f);V=l.toNumber(M)/l.toNumber(ie),p=l.toNumber(l.divide(ne,ie)),M=be,v=0;break}case"day":{const G=Q;M=l.add(l.multiply(G,l.BigInt(v)),M);const O=ot(M,l.toNumber(l.multiply(G,l.BigInt(m))),f);V=l.toNumber(M)/l.toNumber(G),v=l.toNumber(l.divide(O,G)),M=be;break}case"hour":{let O=l.multiply(l.BigInt(T),l.BigInt(36e11));O=l.add(O,l.multiply(l.BigInt(b),l.BigInt(6e10))),O=l.add(O,l.multiply(l.BigInt(D),Zt)),O=l.add(O,l.multiply(l.BigInt(_),dt)),O=l.add(O,l.multiply(l.BigInt(C),re)),O=l.add(O,M),V=l.toNumber(O)/36e11;const B=ot(O,36e11*m,f);T=l.toNumber(l.divide(B,l.BigInt(36e11))),M=be,b=D=_=C=0;break}case"minute":{let O=l.multiply(l.BigInt(b),l.BigInt(6e10));O=l.add(O,l.multiply(l.BigInt(D),Zt)),O=l.add(O,l.multiply(l.BigInt(_),dt)),O=l.add(O,l.multiply(l.BigInt(C),re)),O=l.add(O,M),V=l.toNumber(O)/6e10;const B=ot(O,6e10*m,f);b=l.toNumber(l.divide(B,l.BigInt(6e10))),M=be,D=_=C=0;break}case"second":{let O=l.multiply(l.BigInt(D),Zt);O=l.add(O,l.multiply(l.BigInt(_),dt)),O=l.add(O,l.multiply(l.BigInt(C),re)),O=l.add(O,M),V=l.toNumber(O)/1e9;const B=ot(O,1e9*m,f);D=l.toNumber(l.divide(B,l.BigInt(1e9))),M=be,_=C=0;break}case"millisecond":{let O=l.multiply(l.BigInt(_),dt);O=l.add(O,l.multiply(l.BigInt(C),re)),O=l.add(O,M),V=l.toNumber(O)/1e6;const B=ot(O,1e6*m,f);_=l.toNumber(l.divide(B,l.BigInt(1e6))),M=be,C=0;break}case"microsecond":{let O=l.multiply(l.BigInt(C),re);O=l.add(O,M),V=l.toNumber(O)/1e3;const B=ot(O,1e3*m,f);C=l.toNumber(l.divide(B,l.BigInt(1e3))),M=be;break}case"nanosecond":V=l.toNumber(M),M=ot(M,m,f)}return{years:g,months:w,weeks:p,days:v,hours:T,minutes:b,seconds:D,milliseconds:_,microseconds:C,nanoseconds:l.toNumber(M),total:V}}function Lt(i,e,t,n,r,s){for(const[a,c]of[[i,n],[e,r],[t,s]])if(a!==c)return tn(a-c);return 0}function dn(i,e){let t=i%e;return Ks(t,-0)?0:(t<0&&(t+=e),t)}function Mr(i){const e=Pn(i);return globalThis.BigInt!==void 0?globalThis.BigInt(e.toString(10)):e}function Pn(i){if(i instanceof l)return i;let e=i;if(typeof i=="object"){const t=i[Symbol.toPrimitive];t&&typeof t=="function"&&(e=po(t,i,["number"]))}switch(typeof e){case"undefined":case"object":case"number":case"symbol":default:throw new TypeError(`cannot convert ${typeof i} to bigint`);case"string":if(!e.match(/^\s*(?:[+-]?\d+\s*)?$/))throw new SyntaxError("invalid BigInt syntax");case"bigint":try{return l.BigInt(e.toString())}catch(t){throw t instanceof Error&&t.message.startsWith("Invalid integer")?new SyntaxError(t.message):t}case"boolean":return e?vo:be}}const No=(()=>{let i=l.BigInt(Date.now()%1e6);return()=>{const e=l.BigInt(Date.now()),t=l.add(l.multiply(e,dt),i);return i=l.divide(e,dt),l.greaterThan(t,jn)?jn:l.lessThan(t,Zn)?Zn:t}})();function tn(i){return i<0?-1:i>0?1:i}function z(i){if(i===void 0)return le(null);if(he(i)&&i!==null)return i;throw new TypeError("Options parameter must be an object, not "+(i===null?"null":typeof i))}function bn(i,e){const t=le(null);return t[i]=e,t}function Rt(i,e,t,n){let r=i[e];if(r!==void 0){if(r=x(r),!t.includes(r))throw new RangeError(`${e} must be one of ${t.join(", ")}, not ${r}`);return r}return n}const es=new RegExp(`^${Ti.source}$`);function ts(i,e,t,n=i(e),r=i(t)){let s=l.BigInt(e),a=l.BigInt(t),c=n,h=r;for(;l.greaterThan(l.subtract(a,s),vo);){const d=l.divide(l.add(s,a),l.BigInt(2)),m=i(d);if(m===c)s=d,c=m;else{if(m!==h)throw new Error(`invalid state in bisection ${c} - ${m} - ${h}`);a=d,h=m}}return a}const Po={hour:36e11,minute:6e10,second:1e9,millisecond:1e6,microsecond:1e3,nanosecond:1},ns=Symbol("date"),rs=Symbol("ym"),os=Symbol("md"),is=Symbol("time"),ss=Symbol("datetime"),as=Symbol("zoneddatetime"),cs=Symbol("instant"),gn=Symbol("original"),mo=Symbol("timezone"),mr=Symbol("timezone-id-given"),st=Symbol("calendar-id"),ls=Symbol("locale"),fo=Symbol("options"),Ln=i=>({value:i,enumerable:!0,writable:!1,configurable:!0}),nn=globalThis.Intl.DateTimeFormat,$t=Object.assign,na=Object.prototype.hasOwnProperty,ra=Reflect.apply;function Bt(i,e){let t=i[e];return typeof t=="function"&&(t=new nn(i[ls],t(i[fo])),i[e]=t),t}function kn(i){let e=i[mo];return typeof e=="string"&&(e=et(e),i[mo]=e),e}function sn(i,e={}){if(!(this instanceof sn))return new sn(i,e);const t=e!==void 0,n=t?$t({},e):{},r=new nn(i,n),s=r.resolvedOptions();if(t){const a=$t({},s);for(const c in a)ra(na,n,[c])||delete a[c];this[fo]=a}else this[fo]=n;this[mr]=n.timeZone?n.timeZone:null,this[ls]=s.locale,this[gn]=r,this[mo]=s.timeZone,this[st]=s.calendar,this[ns]=aa,this[rs]=ia,this[os]=sa,this[is]=oa,this[ss]=ca,this[as]=la,this[cs]=ha}Object.defineProperty(sn,"name",{writable:!0,value:"DateTimeFormat"}),sn.supportedLocalesOf=function(i,e){return nn.supportedLocalesOf(i,e)};const Br={resolvedOptions:Ln(function(){return this[gn].resolvedOptions()}),format:Ln(function(e,...t){let{instant:n,formatter:r,timeZone:s}=wn(e,this);return n&&r?(r=Or(r,s),r.format(n.epochMilliseconds)):this[gn].format(e,...t)}),formatRange:Ln(function(e,t){if(Dn(e)||Dn(t)){if(!hs(e,t))throw new TypeError("Intl.DateTimeFormat.formatRange accepts two values of the same type");const{instant:n,formatter:r,timeZone:s}=wn(e,this),{instant:a,formatter:c,timeZone:h}=wn(t,this);if(s&&h&&s!==h)throw new RangeError("cannot format range between different time zones");if(n&&a&&r&&c&&r===c)return Or(r,s).formatRange(n.epochMilliseconds,a.epochMilliseconds)}return this[gn].formatRange(e,t)})};"formatToParts"in nn.prototype&&(Br.formatToParts=Ln(function(e,...t){let{instant:n,formatter:r,timeZone:s}=wn(e,this);return n&&r?(r=Or(r,s),r.formatToParts(n.epochMilliseconds)):this[gn].formatToParts(e,...t)})),"formatRangeToParts"in nn.prototype&&(Br.formatRangeToParts=Ln(function(e,t){if(Dn(e)||Dn(t)){if(!hs(e,t))throw new TypeError("Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type");const{instant:n,formatter:r,timeZone:s}=wn(e,this),{instant:a,formatter:c,timeZone:h}=wn(t,this);if(s&&h&&s!==h)throw new RangeError("cannot format range between different time zones");if(n&&a&&r&&c&&r===c)return Or(r,s).formatRangeToParts(n.epochMilliseconds,a.epochMilliseconds)}return this[gn].formatRangeToParts(e,t)})),sn.prototype=Object.create(nn.prototype,Br),Object.defineProperty(sn,"prototype",{writable:!1,enumerable:!1,configurable:!1});const Vt=sn;function Or(i,e){if(!e)return i;const t=i.resolvedOptions();return t.timeZone===e?i:((t.dateStyle||t.timeStyle)&&(delete t.weekday,delete t.era,delete t.year,delete t.month,delete t.day,delete t.hour,delete t.minute,delete t.second,delete t.timeZoneName,delete t.hourCycle,delete t.hour12,delete t.dayPeriod),new nn(t.locale,{...t,timeZone:e}))}function rr(i={},e={}){const t=$t({},i);for(const n of["year","month","day","hour","minute","second","weekday","dayPeriod","timeZoneName","dateStyle","timeStyle"])t[n]=n in e?e[n]:t[n],t[n]!==!1&&t[n]!==void 0||delete t[n];return t}function oa(i){let e=rr(i,{year:!1,month:!1,day:!1,weekday:!1,timeZoneName:!1,dateStyle:!1});return Ar(e)||(e=$t({},e,{hour:"numeric",minute:"numeric",second:"numeric"})),e}function ia(i){let e=rr(i,{day:!1,hour:!1,minute:!1,second:!1,weekday:!1,dayPeriod:!1,timeZoneName:!1,dateStyle:!1,timeStyle:!1});return"year"in e||"month"in e||(e=$t(e,{year:"numeric",month:"numeric"})),e}function sa(i){let e=rr(i,{year:!1,hour:!1,minute:!1,second:!1,weekday:!1,dayPeriod:!1,timeZoneName:!1,dateStyle:!1,timeStyle:!1});return"month"in e||"day"in e||(e=$t({},e,{month:"numeric",day:"numeric"})),e}function aa(i){let e=rr(i,{hour:!1,minute:!1,second:!1,dayPeriod:!1,timeZoneName:!1,timeStyle:!1});return jr(e)||(e=$t({},e,{year:"numeric",month:"numeric",day:"numeric"})),e}function ca(i){let e=rr(i,{timeZoneName:!1});return Ar(e)||jr(e)||(e=$t({},e,{year:"numeric",month:"numeric",day:"numeric",hour:"numeric",minute:"numeric",second:"numeric"})),e}function la(i){let e=i;return Ar(e)||jr(e)||(e=$t({},e,{year:"numeric",month:"numeric",day:"numeric",hour:"numeric",minute:"numeric",second:"numeric"}),e.timeZoneName===void 0&&(e.timeZoneName="short")),e}function ha(i){let e=i;return Ar(e)||jr(e)||(e=$t({},e,{year:"numeric",month:"numeric",day:"numeric",hour:"numeric",minute:"numeric",second:"numeric"})),e}function jr(i){return"year"in i||"month"in i||"day"in i||"weekday"in i||"dateStyle"in i}function Ar(i){return"hour"in i||"minute"in i||"second"in i||"timeStyle"in i||"dayPeriod"in i}function Dn(i){return X(i)||we(i)||W(i)||Y(i)||te(i)||Ie(i)||Ce(i)}function hs(i,e){return!(!Dn(i)||!Dn(e))&&!(we(i)&&!we(e))&&!(X(i)&&!X(e))&&!(W(i)&&!W(e))&&!(Y(i)&&!Y(e))&&!(te(i)&&!te(e))&&!(Ie(i)&&!Ie(e))&&!(Ce(i)&&!Ce(e))}function wn(i,e){const t=F("%Temporal.PlainDateTime%");if(we(i)){const n=new t(1970,1,1,o(i,Z),o(i,j),o(i,A),o(i,S),o(i,q),o(i,U),e[st]);return{instant:Je(kn(e),n,"compatible"),formatter:Bt(e,is)}}if(te(i)){const n=o(i,R),r=o(i,$),s=o(i,I),a=x(o(i,E));if(a!==e[st])throw new RangeError(`cannot format PlainYearMonth with calendar ${a} in locale with calendar ${e[st]}`);const c=new t(n,r,s,12,0,0,0,0,0,a);return{instant:Je(kn(e),c,"compatible"),formatter:Bt(e,rs)}}if(Ie(i)){const n=o(i,R),r=o(i,$),s=o(i,I),a=x(o(i,E));if(a!==e[st])throw new RangeError(`cannot format PlainMonthDay with calendar ${a} in locale with calendar ${e[st]}`);const c=new t(n,r,s,12,0,0,0,0,0,a);return{instant:Je(kn(e),c,"compatible"),formatter:Bt(e,os)}}if(X(i)){const n=o(i,R),r=o(i,$),s=o(i,I),a=x(o(i,E));if(a!=="iso8601"&&a!==e[st])throw new RangeError(`cannot format PlainDate with calendar ${a} in locale with calendar ${e[st]}`);const c=new t(n,r,s,12,0,0,0,0,0,e[st]);return{instant:Je(kn(e),c,"compatible"),formatter:Bt(e,ns)}}if(W(i)){const n=o(i,R),r=o(i,$),s=o(i,I),a=o(i,Z),c=o(i,j),h=o(i,A),d=o(i,S),m=o(i,q),u=o(i,U),f=x(o(i,E));if(f!=="iso8601"&&f!==e[st])throw new RangeError(`cannot format PlainDateTime with calendar ${f} in locale with calendar ${e[st]}`);let y=i;return f==="iso8601"&&(y=new t(n,r,s,a,c,h,d,m,u,e[st])),{instant:Je(kn(e),y,"compatible"),formatter:Bt(e,ss)}}if(Y(i)){const n=x(o(i,E));if(n!=="iso8601"&&n!==e[st])throw new RangeError(`cannot format ZonedDateTime with calendar ${n} in locale with calendar ${e[st]}`);const r=x(o(i,J));if(e[mr]&&e[mr]!==r)throw new RangeError(`timeZone option ${e[mr]} doesn't match actual time zone ${r}`);return{instant:o(i,je),formatter:Bt(e,as),timeZone:r}}return Ce(i)?{instant:i,formatter:Bt(e,cs)}:{}}Object.freeze({__proto__:null,DateTimeFormat:Vt});const In=["year","month","week","day"],ai={hour:24,minute:60,second:60,millisecond:1e3,microsecond:1e3,nanosecond:1e3};class ht{constructor(e){if(arguments.length<1)throw new TypeError("missing argument: epochNanoseconds is required");const t=Pn(e);Xt(t),It(this),H(this,P,t)}get epochSeconds(){if(!Ce(this))throw new TypeError("invalid receiver");const e=o(this,P);return l.toNumber(l.divide(e,Zt))}get epochMilliseconds(){if(!Ce(this))throw new TypeError("invalid receiver");const e=l.BigInt(o(this,P));return l.toNumber(l.divide(e,dt))}get epochMicroseconds(){if(!Ce(this))throw new TypeError("invalid receiver");const e=l.BigInt(o(this,P));return Mr(l.divide(e,re))}get epochNanoseconds(){if(!Ce(this))throw new TypeError("invalid receiver");return Mr(l.BigInt(o(this,P)))}add(e){if(!Ce(this))throw new TypeError("invalid receiver");const{hours:t,minutes:n,seconds:r,milliseconds:s,microseconds:a,nanoseconds:c}=wt(e,["years","months","weeks","days"]),h=Dr(o(this,P),t,n,r,s,a,c);return new ht(h)}subtract(e){if(!Ce(this))throw new TypeError("invalid receiver");const{hours:t,minutes:n,seconds:r,milliseconds:s,microseconds:a,nanoseconds:c}=wt(e,["years","months","weeks","days"]),h=Dr(o(this,P),-t,-n,-r,-s,-a,-c);return new ht(h)}until(e,t){if(!Ce(this))throw new TypeError("invalid receiver");const n=Et(e),r=z(t),s=Qe(r,"nanosecond",In),a=pt("second",s),c=ct(r,"auto",In,a);mt(c,s);const h=Me(r,"trunc"),d=ut(r,ai[s],!1),m=o(this,P),u=o(n,P);let f,y,{seconds:g,milliseconds:w,microseconds:p,nanoseconds:v}=Wn(m,u,d,s,h);return{hours:f,minutes:y,seconds:g,milliseconds:w,microseconds:p,nanoseconds:v}=xe(0,0,0,g,w,p,v,c),new(F("%Temporal.Duration%"))(0,0,0,0,f,y,g,w,p,v)}since(e,t){if(!Ce(this))throw new TypeError("invalid receiver");const n=Et(e),r=z(t),s=Qe(r,"nanosecond",In),a=pt("second",s),c=ct(r,"auto",In,a);mt(c,s);const h=Me(r,"trunc"),d=ut(r,ai[s],!1),m=o(n,P),u=o(this,P);let f,y,{seconds:g,milliseconds:w,microseconds:p,nanoseconds:v}=Wn(m,u,d,s,h);return{hours:f,minutes:y,seconds:g,milliseconds:w,microseconds:p,nanoseconds:v}=xe(0,0,0,g,w,p,v,c),new(F("%Temporal.Duration%"))(0,0,0,0,f,y,g,w,p,v)}round(e){if(!Ce(this))throw new TypeError("invalid receiver");if(e===void 0)throw new TypeError("options parameter is required");const t=typeof e=="string"?bn("smallestUnit",e):z(e),n=Qe(t,void 0,In);if(n===void 0)throw new RangeError("smallestUnit is required");const r=Me(t,"halfExpand"),s=ut(t,{hour:24,minute:1440,second:86400,millisecond:864e5,microsecond:864e8,nanosecond:864e11}[n],!0),a=Cr(o(this,P),s,n,r);return new ht(a)}equals(e){if(!Ce(this))throw new TypeError("invalid receiver");const t=Et(e),n=o(this,P),r=o(t,P);return l.equal(l.BigInt(n),l.BigInt(r))}toString(e){if(!Ce(this))throw new TypeError("invalid receiver");const t=z(e);let n=t.timeZone;n!==void 0&&(n=et(n));const{precision:r,unit:s,increment:a}=Jn(t),c=Me(t,"trunc"),h=Cr(o(this,P),a,s,c);return Jo(new ht(h),n,r)}toJSON(){if(!Ce(this))throw new TypeError("invalid receiver");return Jo(this,void 0,"auto")}toLocaleString(e,t){if(!Ce(this))throw new TypeError("invalid receiver");return new Vt(e,t).format(this)}valueOf(){throw new TypeError("use compare() or equals() to compare Temporal.Instant")}toZonedDateTime(e){if(!Ce(this))throw new TypeError("invalid receiver");if(!he(e))throw new TypeError("invalid argument in toZonedDateTime");const t=e.calendar;if(t===void 0)throw new TypeError("missing calendar property in toZonedDateTime");const n=Ze(t),r=e.timeZone;if(r===void 0)throw new TypeError("missing timeZone property in toZonedDateTime");const s=et(r);return Ne(o(this,P),s,n)}toZonedDateTimeISO(e){let t=e;if(!Ce(this))throw new TypeError("invalid receiver");if(he(t)){const s=t.timeZone;s!==void 0&&(t=s)}const n=et(t),r=De();return Ne(o(this,P),n,r)}static fromEpochSeconds(e){const t=An(e),n=l.multiply(l.BigInt(t),Zt);return Xt(n),new ht(n)}static fromEpochMilliseconds(e){const t=An(e),n=l.multiply(l.BigInt(t),dt);return Xt(n),new ht(n)}static fromEpochMicroseconds(e){const t=Pn(e),n=l.multiply(t,re);return Xt(n),new ht(n)}static fromEpochNanoseconds(e){const t=Pn(e);return Xt(t),new ht(t)}static from(e){return Ce(e)?new ht(o(e,P)):Et(e)}static compare(e,t){const n=Et(e),r=Et(t),s=o(n,P),a=o(r,P);return l.lessThan(s,a)?-1:l.greaterThan(s,a)?1:0}}kt(ht,"Temporal.Instant");const cr=["hour","minute","second","millisecond","microsecond","nanosecond"];class or{constructor(e,t,n,r=De()){const s=ce(e),a=ce(t),c=ce(n),h=Ze(r);if(arguments.length<3)throw new RangeError("missing argument: isoYear, isoMonth and isoDay are required");Li(this,s,a,c,h)}get calendar(){if(!X(this))throw new TypeError("invalid receiver");return o(this,E)}get era(){if(!X(this))throw new TypeError("invalid receiver");return Yr(o(this,E),this)}get eraYear(){if(!X(this))throw new TypeError("invalid receiver");return Nr(o(this,E),this)}get year(){if(!X(this))throw new TypeError("invalid receiver");return $r(o(this,E),this)}get month(){if(!X(this))throw new TypeError("invalid receiver");return kr(o(this,E),this)}get monthCode(){if(!X(this))throw new TypeError("invalid receiver");return tr(o(this,E),this)}get day(){if(!X(this))throw new TypeError("invalid receiver");return Ir(o(this,E),this)}get dayOfWeek(){if(!X(this))throw new TypeError("invalid receiver");return bo(o(this,E),this)}get dayOfYear(){if(!X(this))throw new TypeError("invalid receiver");return Do(o(this,E),this)}get weekOfYear(){if(!X(this))throw new TypeError("invalid receiver");return _o(o(this,E),this)}get daysInWeek(){if(!X(this))throw new TypeError("invalid receiver");return Co(o(this,E),this)}get daysInMonth(){if(!X(this))throw new TypeError("invalid receiver");return yn(o(this,E),this)}get daysInYear(){if(!X(this))throw new TypeError("invalid receiver");return Pr(o(this,E),this)}get monthsInYear(){if(!X(this))throw new TypeError("invalid receiver");return Lr(o(this,E),this)}get inLeapYear(){if(!X(this))throw new TypeError("invalid receiver");return Fr(o(this,E),this)}with(e,t){if(!X(this))throw new TypeError("invalid receiver");if(!he(e))throw new TypeError("invalid argument");On(e);const n=o(this,E),r=ve(n,["day","month","monthCode","year"]),s=Ht(e,r);if(!s)throw new TypeError("invalid date-like");let a=oo(this,r);return a=rn(n,a,s),a=oo(a,r),Tt(n,a,z(t))}withCalendar(e){if(!X(this))throw new TypeError("invalid receiver");const t=Ze(e);return new or(o(this,R),o(this,$),o(this,I),t)}add(e,t){if(!X(this))throw new TypeError("invalid receiver");const n=fn(e),r=z(t);return Xe(o(this,E),this,n,r)}subtract(e,t){if(!X(this))throw new TypeError("invalid receiver");const n=Vi(fn(e)),r=z(t);return Xe(o(this,E),this,n,r)}until(e,t){if(!X(this))throw new TypeError("invalid receiver");const n=ae(e),r=o(this,E),s=o(n,E),a=x(r),c=x(s);if(a!==c)throw new RangeError(`cannot compute difference between dates of ${a} and ${c} calendars`);const h=z(t),d=Qe(h,"day",cr),m=pt("day",d),u=ct(h,"auto",cr,m);mt(u,d);const f=Me(h,"trunc"),y=ut(h,void 0,!1),g=Mt(r,this,n,{...h,largestUnit:u});if(d==="day"&&y===1)return g;let{years:w,months:p,weeks:v,days:T}=g;return{years:w,months:p,weeks:v,days:T}=ft(w,p,v,T,0,0,0,0,0,0,y,d,f,this),new(F("%Temporal.Duration%"))(w,p,v,T,0,0,0,0,0,0)}since(e,t){if(!X(this))throw new TypeError("invalid receiver");const n=ae(e),r=o(this,E),s=o(n,E),a=x(r),c=x(s);if(a!==c)throw new RangeError(`cannot compute difference between dates of ${a} and ${c} calendars`);const h=z(t),d=Qe(h,"day",cr),m=pt("day",d),u=ct(h,"auto",cr,m);mt(u,d);const f=Me(h,"trunc"),y=ut(h,void 0,!1),g={...h,largestUnit:u};let{years:w,months:p,weeks:v,days:T}=Mt(r,this,n,g);const b=F("%Temporal.Duration%");return d==="day"&&y===1||({years:w,months:p,weeks:v,days:T}=ft(w,p,v,T,0,0,0,0,0,0,y,d,Qn(f),this)),new b(-w,-p,-v,-T,0,0,0,0,0,0)}equals(e){if(!X(this))throw new TypeError("invalid receiver");const t=ae(e);for(const n of[R,$,I])if(o(this,n)!==o(t,n))return!1;return nr(o(this,E),o(t,E))}toString(e){if(!X(this))throw new TypeError("invalid receiver");return ei(this,Kn(z(e)))}toJSON(){if(!X(this))throw new TypeError("invalid receiver");return ei(this)}toLocaleString(e,t){if(!X(this))throw new TypeError("invalid receiver");return new Vt(e,t).format(this)}valueOf(){throw new TypeError("use compare() or equals() to compare Temporal.PlainDate")}toPlainDateTime(e){if(!X(this))throw new TypeError("invalid receiver");const t=o(this,R),n=o(this,$),r=o(this,I),s=o(this,E);if(e===void 0)return tt(t,n,r,0,0,0,0,0,0,s);const a=_t(e);return tt(t,n,r,o(a,Z),o(a,j),o(a,A),o(a,S),o(a,q),o(a,U),s)}toZonedDateTime(e){if(!X(this))throw new TypeError("invalid receiver");let t,n;if(he(e)){const g=e.timeZone;g===void 0?t=et(e):(t=et(g),n=e.plainTime)}else t=et(e);const r=o(this,R),s=o(this,$),a=o(this,I),c=o(this,E);let h=0,d=0,m=0,u=0,f=0,y=0;return n!==void 0&&(n=_t(n),h=o(n,Z),d=o(n,j),m=o(n,A),u=o(n,S),f=o(n,q),y=o(n,U)),Ne(o(Je(t,tt(r,s,a,h,d,m,u,f,y,c),"compatible"),P),t,c)}toPlainYearMonth(){if(!X(this))throw new TypeError("invalid receiver");const e=o(this,E);return zt(e,rt(this,ve(e,["monthCode","year"])))}toPlainMonthDay(){if(!X(this))throw new TypeError("invalid receiver");const e=o(this,E);return Tn(e,Kt(this,ve(e,["day","monthCode"])))}getISOFields(){if(!X(this))throw new TypeError("invalid receiver");return{calendar:o(this,E),isoDay:o(this,I),isoMonth:o(this,$),isoYear:o(this,R)}}static from(e,t){const n=z(t);return X(e)?(Le(n),vt(o(e,R),o(e,$),o(e,I),o(e,E))):ae(e,n)}static compare(e,t){const n=ae(e),r=ae(t);return Lt(o(n,R),o(n,$),o(n,I),o(r,R),o(r,$),o(r,I))}}kt(or,"Temporal.PlainDate");class ir{constructor(e,t,n,r=0,s=0,a=0,c=0,h=0,d=0,m=De()){const u=ce(e),f=ce(t),y=ce(n),g=ce(r),w=ce(s),p=ce(a),v=ce(c),T=ce(h),b=ce(d),D=Ze(m);if(arguments.length<3)throw new RangeError("missing argument: isoYear, isoMonth and isoDay are required");Fi(this,u,f,y,g,w,p,v,T,b,D)}get calendar(){if(!W(this))throw new TypeError("invalid receiver");return o(this,E)}get year(){if(!W(this))throw new TypeError("invalid receiver");return $r(o(this,E),this)}get month(){if(!W(this))throw new TypeError("invalid receiver");return kr(o(this,E),this)}get monthCode(){if(!W(this))throw new TypeError("invalid receiver");return tr(o(this,E),this)}get day(){if(!W(this))throw new TypeError("invalid receiver");return Ir(o(this,E),this)}get hour(){if(!W(this))throw new TypeError("invalid receiver");return o(this,Z)}get minute(){if(!W(this))throw new TypeError("invalid receiver");return o(this,j)}get second(){if(!W(this))throw new TypeError("invalid receiver");return o(this,A)}get millisecond(){if(!W(this))throw new TypeError("invalid receiver");return o(this,S)}get microsecond(){if(!W(this))throw new TypeError("invalid receiver");return o(this,q)}get nanosecond(){if(!W(this))throw new TypeError("invalid receiver");return o(this,U)}get era(){if(!W(this))throw new TypeError("invalid receiver");return Yr(o(this,E),this)}get eraYear(){if(!W(this))throw new TypeError("invalid receiver");return Nr(o(this,E),this)}get dayOfWeek(){if(!W(this))throw new TypeError("invalid receiver");return bo(o(this,E),this)}get dayOfYear(){if(!W(this))throw new TypeError("invalid receiver");return Do(o(this,E),this)}get weekOfYear(){if(!W(this))throw new TypeError("invalid receiver");return _o(o(this,E),this)}get daysInWeek(){if(!W(this))throw new TypeError("invalid receiver");return Co(o(this,E),this)}get daysInYear(){if(!W(this))throw new TypeError("invalid receiver");return Pr(o(this,E),this)}get daysInMonth(){if(!W(this))throw new TypeError("invalid receiver");return yn(o(this,E),this)}get monthsInYear(){if(!W(this))throw new TypeError("invalid receiver");return Lr(o(this,E),this)}get inLeapYear(){if(!W(this))throw new TypeError("invalid receiver");return Fr(o(this,E),this)}with(e,t){if(!W(this))throw new TypeError("invalid receiver");if(!he(e))throw new TypeError("invalid argument");On(e);const n=z(t),r=o(this,E),s=ve(r,["day","hour","microsecond","millisecond","minute","month","monthCode","nanosecond","second","year"]),a=Ht(e,s);if(!a)throw new TypeError("invalid date-time-like");let c=pr(this,s);c=rn(r,c,a),c=pr(c,s);const{year:h,month:d,day:m,hour:u,minute:f,second:y,millisecond:g,microsecond:w,nanosecond:p}=er(r,c,n);return tt(h,d,m,u,f,y,g,w,p,r)}withPlainTime(e){if(!W(this))throw new TypeError("invalid receiver");const t=o(this,R),n=o(this,$),r=o(this,I),s=o(this,E);if(e===void 0)return tt(t,n,r,0,0,0,0,0,0,s);const a=_t(e);return tt(t,n,r,o(a,Z),o(a,j),o(a,A),o(a,S),o(a,q),o(a,U),s)}withPlainDate(e){if(!W(this))throw new TypeError("invalid receiver");const t=ae(e),n=o(t,R),r=o(t,$),s=o(t,I);let a=o(t,E);const c=o(this,Z),h=o(this,j),d=o(this,A),m=o(this,S),u=o(this,q),f=o(this,U);return a=Ai(o(this,E),a),tt(n,r,s,c,h,d,m,u,f,a)}withCalendar(e){if(!W(this))throw new TypeError("invalid receiver");const t=Ze(e);return new ir(o(this,R),o(this,$),o(this,I),o(this,Z),o(this,j),o(this,A),o(this,S),o(this,q),o(this,U),t)}add(e,t){if(!W(this))throw new TypeError("invalid receiver");const n=wt(e),{years:r,months:s,weeks:a,days:c,hours:h,minutes:d,seconds:m,milliseconds:u,microseconds:f,nanoseconds:y}=n,g=z(t),w=o(this,E),{year:p,month:v,day:T,hour:b,minute:D,second:_,millisecond:C,microsecond:M,nanosecond:k}=_r(o(this,R),o(this,$),o(this,I),o(this,Z),o(this,j),o(this,A),o(this,S),o(this,q),o(this,U),w,r,s,a,c,h,d,m,u,f,y,g);return tt(p,v,T,b,D,_,C,M,k,w)}subtract(e,t){if(!W(this))throw new TypeError("invalid receiver");const n=wt(e),{years:r,months:s,weeks:a,days:c,hours:h,minutes:d,seconds:m,milliseconds:u,microseconds:f,nanoseconds:y}=n,g=z(t),w=o(this,E),{year:p,month:v,day:T,hour:b,minute:D,second:_,millisecond:C,microsecond:M,nanosecond:k}=_r(o(this,R),o(this,$),o(this,I),o(this,Z),o(this,j),o(this,A),o(this,S),o(this,q),o(this,U),w,-r,-s,-a,-c,-h,-d,-m,-u,-f,-y,g);return tt(p,v,T,b,D,_,C,M,k,w)}until(e,t){if(!W(this))throw new TypeError("invalid receiver");const n=St(e),r=o(this,E),s=o(n,E),a=x(r),c=x(s);if(a!==c)throw new RangeError(`cannot compute difference between dates of ${a} and ${c} calendars`);const h=z(t),d=Qe(h,"nanosecond"),m=ct(h,"auto",[],pt("day",d));mt(m,d);const u=Me(h,"trunc"),f=qn(h,d);let{years:y,months:g,weeks:w,days:p,hours:v,minutes:T,seconds:b,milliseconds:D,microseconds:_,nanoseconds:C}=br(o(this,R),o(this,$),o(this,I),o(this,Z),o(this,j),o(this,A),o(this,S),o(this,q),o(this,U),o(n,R),o(n,$),o(n,I),o(n,Z),o(n,j),o(n,A),o(n,S),o(n,q),o(n,U),r,m,h);const M=Jt(this);return{years:y,months:g,weeks:w,days:p,hours:v,minutes:T,seconds:b,milliseconds:D,microseconds:_,nanoseconds:C}=ft(y,g,w,p,v,T,b,D,_,C,f,d,u,M),{days:p,hours:v,minutes:T,seconds:b,milliseconds:D,microseconds:_,nanoseconds:C}=xe(p,v,T,b,D,_,C,m),new(F("%Temporal.Duration%"))(y,g,w,p,v,T,b,D,_,C)}since(e,t){if(!W(this))throw new TypeError("invalid receiver");const n=St(e),r=o(this,E),s=o(n,E),a=x(r),c=x(s);if(a!==c)throw new RangeError(`cannot compute difference between dates of ${a} and ${c} calendars`);const h=z(t),d=Qe(h,"nanosecond"),m=ct(h,"auto",[],pt("day",d));mt(m,d);const u=Me(h,"trunc"),f=qn(h,d);let{years:y,months:g,weeks:w,days:p,hours:v,minutes:T,seconds:b,milliseconds:D,microseconds:_,nanoseconds:C}=br(o(this,R),o(this,$),o(this,I),o(this,Z),o(this,j),o(this,A),o(this,S),o(this,q),o(this,U),o(n,R),o(n,$),o(n,I),o(n,Z),o(n,j),o(n,A),o(n,S),o(n,q),o(n,U),r,m,h);const M=Jt(this);return{years:y,months:g,weeks:w,days:p,hours:v,minutes:T,seconds:b,milliseconds:D,microseconds:_,nanoseconds:C}=ft(y,g,w,p,v,T,b,D,_,C,f,d,Qn(u),M),{days:p,hours:v,minutes:T,seconds:b,milliseconds:D,microseconds:_,nanoseconds:C}=xe(p,v,T,b,D,_,C,m),new(F("%Temporal.Duration%"))(-y,-g,-w,-p,-v,-T,-b,-D,-_,-C)}round(e){if(!W(this))throw new TypeError("invalid receiver");if(e===void 0)throw new TypeError("options parameter is required");const t=typeof e=="string"?bn("smallestUnit",e):z(e),n=Qe(t,void 0,["year","month","week"]);if(n===void 0)throw new RangeError("smallestUnit is required");const r=Me(t,"halfExpand"),s=ut(t,{day:1,hour:24,minute:60,second:60,millisecond:1e3,microsecond:1e3,nanosecond:1e3}[n],!1);let a=o(this,R),c=o(this,$),h=o(this,I),d=o(this,Z),m=o(this,j),u=o(this,A),f=o(this,S),y=o(this,q),g=o(this,U);return{year:a,month:c,day:h,hour:d,minute:m,second:u,millisecond:f,microsecond:y,nanosecond:g}=Io(a,c,h,d,m,u,f,y,g,s,n,r),tt(a,c,h,d,m,u,f,y,g,o(this,E))}equals(e){if(!W(this))throw new TypeError("invalid receiver");const t=St(e);for(const n of[R,$,I,Z,j,A,S,q,U])if(o(this,n)!==o(t,n))return!1;return nr(o(this,E),o(t,E))}toString(e){if(!W(this))throw new TypeError("invalid receiver");const t=z(e),{precision:n,unit:r,increment:s}=Jn(t);return ti(this,n,Kn(t),{unit:r,increment:s,roundingMode:Me(t,"trunc")})}toJSON(){if(!W(this))throw new TypeError("invalid receiver");return ti(this,"auto")}toLocaleString(e,t){if(!W(this))throw new TypeError("invalid receiver");return new Vt(e,t).format(this)}valueOf(){throw new TypeError("use compare() or equals() to compare Temporal.PlainDateTime")}toZonedDateTime(e,t){if(!W(this))throw new TypeError("invalid receiver");const n=et(e);return Ne(o(Je(n,this,Sn(z(t))),P),n,o(this,E))}toPlainDate(){if(!W(this))throw new TypeError("invalid receiver");return Jt(this)}toPlainYearMonth(){if(!W(this))throw new TypeError("invalid receiver");const e=o(this,E);return zt(e,rt(this,ve(e,["monthCode","year"])))}toPlainMonthDay(){if(!W(this))throw new TypeError("invalid receiver");const e=o(this,E);return Tn(e,Kt(this,ve(e,["day","monthCode"])))}toPlainTime(){if(!W(this))throw new TypeError("invalid receiver");return Mo(this)}getISOFields(){if(!W(this))throw new TypeError("invalid receiver");return{calendar:o(this,E),isoDay:o(this,I),isoHour:o(this,Z),isoMicrosecond:o(this,q),isoMillisecond:o(this,S),isoMinute:o(this,j),isoMonth:o(this,$),isoNanosecond:o(this,U),isoSecond:o(this,A),isoYear:o(this,R)}}static from(e,t){const n=z(t);return W(e)?(Le(n),tt(o(e,R),o(e,$),o(e,I),o(e,Z),o(e,j),o(e,A),o(e,S),o(e,q),o(e,U),o(e,E))):St(e,n)}static compare(e,t){const n=St(e),r=St(t);for(const s of[R,$,I,Z,j,A,S,q,U]){const a=o(n,s),c=o(r,s);if(a!==c)return tn(a-c)}return 0}}kt(ir,"Temporal.PlainDateTime");class Ct{constructor(e=0,t=0,n=0,r=0,s=0,a=0,c=0,h=0,d=0,m=0){const u=Ye(e),f=Ye(t),y=Ye(n),g=Ye(r),w=Ye(s),p=Ye(a),v=Ye(c),T=Ye(h),b=Ye(d),D=Ye(m),_=gt(u,f,y,g,w,p,v,T,b,D);for(const C of[u,f,y,g,w,p,v,T,b,D]){if(!Number.isFinite(C))throw new RangeError("infinite values not allowed as duration fields");const M=Math.sign(C);if(M!==0&&M!==_)throw new RangeError("mixed-sign values not allowed as duration fields")}It(this),H(this,Se,u),H(this,Oe,f),H(this,Ke,y),H(this,qe,g),H(this,Ue,w),H(this,ze,p),H(this,Ge,v),H(this,We,T),H(this,He,b),H(this,Ve,D)}get years(){if(!ge(this))throw new TypeError("invalid receiver");return o(this,Se)}get months(){if(!ge(this))throw new TypeError("invalid receiver");return o(this,Oe)}get weeks(){if(!ge(this))throw new TypeError("invalid receiver");return o(this,Ke)}get days(){if(!ge(this))throw new TypeError("invalid receiver");return o(this,qe)}get hours(){if(!ge(this))throw new TypeError("invalid receiver");return o(this,Ue)}get minutes(){if(!ge(this))throw new TypeError("invalid receiver");return o(this,ze)}get seconds(){if(!ge(this))throw new TypeError("invalid receiver");return o(this,Ge)}get milliseconds(){if(!ge(this))throw new TypeError("invalid receiver");return o(this,We)}get microseconds(){if(!ge(this))throw new TypeError("invalid receiver");return o(this,He)}get nanoseconds(){if(!ge(this))throw new TypeError("invalid receiver");return o(this,Ve)}get sign(){if(!ge(this))throw new TypeError("invalid receiver");return gt(o(this,Se),o(this,Oe),o(this,Ke),o(this,qe),o(this,Ue),o(this,ze),o(this,Ge),o(this,We),o(this,He),o(this,Ve))}get blank(){if(!ge(this))throw new TypeError("invalid receiver");return gt(o(this,Se),o(this,Oe),o(this,Ke),o(this,qe),o(this,Ue),o(this,ze),o(this,Ge),o(this,We),o(this,He),o(this,Ve))===0}with(e){if(!ge(this))throw new TypeError("invalid receiver");const t=Ht(e,["days","hours","microseconds","milliseconds","minutes","months","nanoseconds","seconds","weeks","years"]);if(!t)throw new TypeError("invalid duration-like");const{years:n=o(this,Se),months:r=o(this,Oe),weeks:s=o(this,Ke),days:a=o(this,qe),hours:c=o(this,Ue),minutes:h=o(this,ze),seconds:d=o(this,Ge),milliseconds:m=o(this,We),microseconds:u=o(this,He),nanoseconds:f=o(this,Ve)}=t;return new Ct(n,r,s,a,c,h,d,m,u,f)}negated(){if(!ge(this))throw new TypeError("invalid receiver");return Vi(this)}abs(){if(!ge(this))throw new TypeError("invalid receiver");return new Ct(Math.abs(o(this,Se)),Math.abs(o(this,Oe)),Math.abs(o(this,Ke)),Math.abs(o(this,qe)),Math.abs(o(this,Ue)),Math.abs(o(this,ze)),Math.abs(o(this,Ge)),Math.abs(o(this,We)),Math.abs(o(this,He)),Math.abs(o(this,Ve)))}add(e,t){if(!ge(this))throw new TypeError("invalid receiver");let{years:n,months:r,weeks:s,days:a,hours:c,minutes:h,seconds:d,milliseconds:m,microseconds:u,nanoseconds:f}=wt(e);const y=$n(z(t));return{years:n,months:r,weeks:s,days:a,hours:c,minutes:h,seconds:d,milliseconds:m,microseconds:u,nanoseconds:f}=lo(o(this,Se),o(this,Oe),o(this,Ke),o(this,qe),o(this,Ue),o(this,ze),o(this,Ge),o(this,We),o(this,He),o(this,Ve),n,r,s,a,c,h,d,m,u,f,y),new Ct(n,r,s,a,c,h,d,m,u,f)}subtract(e,t){if(!ge(this))throw new TypeError("invalid receiver");let{years:n,months:r,weeks:s,days:a,hours:c,minutes:h,seconds:d,milliseconds:m,microseconds:u,nanoseconds:f}=wt(e);const y=$n(z(t));return{years:n,months:r,weeks:s,days:a,hours:c,minutes:h,seconds:d,milliseconds:m,microseconds:u,nanoseconds:f}=lo(o(this,Se),o(this,Oe),o(this,Ke),o(this,qe),o(this,Ue),o(this,ze),o(this,Ge),o(this,We),o(this,He),o(this,Ve),-n,-r,-s,-a,-c,-h,-d,-m,-u,-f,y),new Ct(n,r,s,a,c,h,d,m,u,f)}round(e){if(!ge(this))throw new TypeError("invalid receiver");if(e===void 0)throw new TypeError("options parameter is required");let t=o(this,Se),n=o(this,Oe),r=o(this,Ke),s=o(this,qe),a=o(this,Ue),c=o(this,ze),h=o(this,Ge),d=o(this,We),m=o(this,He),u=o(this,Ve),f=ro(t,n,r,s,a,c,h,d,m,u);const y=typeof e=="string"?bn("smallestUnit",e):z(e);let g=Qe(y,void 0),w=!0;g||(w=!1,g="nanosecond"),f=pt(f,g);let p=ct(y,void 0),v=!0;if(p||(v=!1,p=f),p==="auto"&&(p=f),!w&&!v)throw new RangeError("at least one of smallestUnit or largestUnit is required");mt(p,g);const T=Me(y,"halfExpand"),b=qn(y,g);let D=$n(y);return{years:t,months:n,weeks:r,days:s}=ar(t,n,r,s,p,D),{years:t,months:n,weeks:r,days:s,hours:a,minutes:c,seconds:h,milliseconds:d,microseconds:m,nanoseconds:u}=ft(t,n,r,s,a,c,h,d,m,u,b,g,T,D),{years:t,months:n,weeks:r,days:s,hours:a,minutes:c,seconds:h,milliseconds:d,microseconds:m,nanoseconds:u}=uo(t,n,r,s,a,c,h,d,m,u,b,g,T,D),{years:t,months:n,weeks:r,days:s}=function(C,M,k,N,K,Q){let V=C,L=M,G=k,O=N;const B=F("%Temporal.Duration%"),ie=gt(V,L,G,O,0,0,0,0,0,0);if(ie===0)return{years:V,months:L,weeks:G,days:O};let ne,se;Q&&(se=ae(Q),ne=o(se,E));const ye=new B(ie),nt=new B(0,ie),yt=new B(0,0,ie);switch(K){case"year":{if(!ne)throw new RangeError("a starting point is required for years balancing");let pe,_e,cn;for({relativeTo:pe,days:_e}=Be(ne,se,ye);ee(O)>=ee(_e);)O-=_e,V+=ie,se=pe,{relativeTo:pe,days:_e}=Be(ne,se,ye);for({relativeTo:pe,days:cn}=Be(ne,se,nt);ee(O)>=ee(cn);)O-=cn,L+=ie,se=pe,{relativeTo:pe,days:cn}=Be(ne,se,nt);const zo=ne.dateAdd;pe=Xe(ne,se,ye,le(null),zo);const Go=ne.dateUntil,Wo=le(null);Wo.largestUnit="month";let qr=Mt(ne,se,pe,Wo,Go),Ur=o(qr,Oe);for(;ee(L)>=ee(Ur);){L-=Ur,V+=ie,se=pe,pe=Xe(ne,se,ye,le(null),zo);const Ho=le(null);Ho.largestUnit="month",qr=Mt(ne,se,pe,Ho,Go),Ur=o(qr,Oe)}break}case"month":{if(!ne)throw new RangeError("a starting point is required for months balancing");let pe,_e;for({relativeTo:pe,days:_e}=Be(ne,se,nt);ee(O)>=ee(_e);)O-=_e,L+=ie,se=pe,{relativeTo:pe,days:_e}=Be(ne,se,nt);break}case"week":{if(!ne)throw new RangeError("a starting point is required for weeks balancing");let pe,_e;for({relativeTo:pe,days:_e}=Be(ne,se,yt);ee(O)>=ee(_e);)O-=_e,G+=ie,se=pe,{relativeTo:pe,days:_e}=Be(ne,se,yt);break}}return{years:V,months:L,weeks:G,days:O}}(t,n,r,s,p,D),Y(D)&&(D=ho(D,t,n,r,0)),{days:s,hours:a,minutes:c,seconds:h,milliseconds:d,microseconds:m,nanoseconds:u}=xe(s,a,c,h,d,m,u,p,D),new Ct(t,n,r,s,a,c,h,d,m,u)}total(e){if(!ge(this))throw new TypeError("invalid receiver");let t=o(this,Se),n=o(this,Oe),r=o(this,Ke),s=o(this,qe),a=o(this,Ue),c=o(this,ze),h=o(this,Ge),d=o(this,We),m=o(this,He),u=o(this,Ve);if(e===void 0)throw new TypeError("options argument is required");const f=typeof e=="string"?bn("unit",e):z(e),y=function(T){const b=new Map(Rr),D=Rt(T,"unit",[...b.values(),...b.keys()],void 0);return b.has(D)?b.get(D):D}(f);if(y===void 0)throw new RangeError("unit option is required");const g=$n(f);let w;({years:t,months:n,weeks:r,days:s}=ar(t,n,r,s,y,g)),Y(g)&&(w=ho(g,t,n,r,0)),{days:s,hours:a,minutes:c,seconds:h,milliseconds:d,microseconds:m,nanoseconds:u}=xe(s,a,c,h,d,m,u,y,w);const{total:p}=ft(t,n,r,s,a,c,h,d,m,u,1,y,"trunc",g);return p}toString(e){if(!ge(this))throw new TypeError("invalid receiver");const t=z(e),{precision:n,unit:r,increment:s}=Jn(t);if(n==="minute")throw new RangeError('smallestUnit must not be "minute"');return Hr(this,n,{unit:r,increment:s,roundingMode:Me(t,"trunc")})}toJSON(){if(!ge(this))throw new TypeError("invalid receiver");return Hr(this)}toLocaleString(e,t){if(!ge(this))throw new TypeError("invalid receiver");return typeof Intl!="undefined"&&Intl.DurationFormat!==void 0?new Intl.DurationFormat(e,t).format(this):(console.warn("Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat."),Hr(this))}valueOf(){throw new TypeError("use compare() to compare Temporal.Duration")}static from(e){return ge(e)?new Ct(o(e,Se),o(e,Oe),o(e,Ke),o(e,qe),o(e,Ue),o(e,ze),o(e,Ge),o(e,We),o(e,He),o(e,Ve)):fn(e)}static compare(e,t,n){const r=fn(e),s=fn(t),a=$n(z(n)),c=o(r,Se),h=o(r,Oe),d=o(r,Ke);let m=o(r,qe);const u=o(r,Ue),f=o(r,ze),y=o(r,Ge),g=o(r,We),w=o(r,He);let p=o(r,Ve);const v=o(s,Se),T=o(s,Oe),b=o(s,Ke);let D=o(s,qe);const _=o(s,Ue),C=o(s,ze),M=o(s,Ge),k=o(s,We),N=o(s,He);let K=o(s,Ve);const Q=si(a,c,h,d,m,u,f,y,g,w,p),V=si(a,v,T,b,D,_,C,M,k,N,K);c===0&&v===0&&h===0&&T===0&&d===0&&b===0||({days:m}=ar(c,h,d,m,"day",a),{days:D}=ar(v,T,b,D,"day",a));const L=En(m,u,f,y,g,w,p,Q),G=En(D,_,C,M,k,N,K,V);return tn(l.toNumber(l.subtract(L,G)))}}kt(Ct,"Temporal.Duration");const da=Object.create;class Lo{constructor(e,t,n=De(),r=1972){const s=ce(e),a=ce(t),c=Ze(n),h=ce(r);if(arguments.length<2)throw new RangeError("missing argument: isoMonth and isoDay are required");xi(this,s,a,c,h)}get monthCode(){if(!Ie(this))throw new TypeError("invalid receiver");return tr(o(this,E),this)}get day(){if(!Ie(this))throw new TypeError("invalid receiver");return Ir(o(this,E),this)}get calendar(){if(!Ie(this))throw new TypeError("invalid receiver");return o(this,E)}with(e,t){if(!Ie(this))throw new TypeError("invalid receiver");if(!he(e))throw new TypeError("invalid argument");On(e);const n=o(this,E),r=ve(n,["day","month","monthCode","year"]),s=Ht(e,r);if(!s)throw new TypeError("invalid month-day-like");let a=Kt(this,r);return a=rn(n,a,s),a=Kt(a,r),Tn(n,a,z(t))}equals(e){if(!Ie(this))throw new TypeError("invalid receiver");const t=Ko(e);for(const n of[$,I,R])if(o(this,n)!==o(t,n))return!1;return nr(o(this,E),o(t,E))}toString(e){if(!Ie(this))throw new TypeError("invalid receiver");return ni(this,Kn(z(e)))}toJSON(){if(!Ie(this))throw new TypeError("invalid receiver");return ni(this)}toLocaleString(e,t){if(!Ie(this))throw new TypeError("invalid receiver");return new Vt(e,t).format(this)}valueOf(){throw new TypeError("use equals() to compare Temporal.PlainMonthDay")}toPlainDate(e){if(!Ie(this))throw new TypeError("invalid receiver");if(!he(e))throw new TypeError("argument should be an object");const t=o(this,E),n=ve(t,["day","monthCode"]),r=Kt(this,n),s=ve(t,["year"]),a=[["year",void 0]];s.forEach(u=>{a.some(([f])=>f===u)||a.push([u,void 0])});let c=rn(t,r,Fe(e,a));const h=[...new Set([...n,...s])],d=[];h.forEach(u=>{d.some(([f])=>f===u)||d.push([u,void 0])}),c=Fe(c,d);const m=da(null);return m.overflow="reject",Tt(t,c,m)}getISOFields(){if(!Ie(this))throw new TypeError("invalid receiver");return{calendar:o(this,E),isoDay:o(this,I),isoMonth:o(this,$),isoYear:o(this,R)}}static from(e,t){const n=z(t);return Ie(e)?(Le(n),Un(o(e,$),o(e,I),o(e,E),o(e,R))):Ko(e,n)}}kt(Lo,"Temporal.PlainMonthDay");const Fo=()=>new(F("%Temporal.Instant%"))(No()),ci=(i,e=qt())=>{const t=et(e),n=Ze(i);return lt(t,Fo(),n)},Xr=(i=qt())=>{const e=et(i),t=De();return lt(e,Fo(),t)},li=(i,e=qt())=>{const t=et(e),n=Ze(i);return Ne(No(),t,n)},qt=()=>function(){const e=new _i("en-us");return new(F("%Temporal.TimeZone%"))(ki(e.resolvedOptions().timeZone))}(),ds={instant:Fo,plainDateTime:ci,plainDateTimeISO:Xr,plainDate:(i,e=qt())=>Jt(ci(i,e)),plainDateISO:(i=qt())=>Jt(Xr(i)),plainTimeISO:(i=qt())=>Mo(Xr(i)),timeZone:qt,zonedDateTime:li,zonedDateTimeISO:(i=qt())=>li(De(),i),[Symbol.toStringTag]:"Temporal.Now"};Object.defineProperty(ds,Symbol.toStringTag,{value:"Temporal.Now",writable:!1,enumerable:!1,configurable:!0});const ua=Object.assign,Yn=["year","month","week","day"],Qr={hour:24,minute:60,second:60,millisecond:1e3,microsecond:1e3,nanosecond:1e3};function hi(i,e,t){let n=o(i,Z),r=o(i,j),s=o(i,A),a=o(i,S),c=o(i,q),h=o(i,U);if(t){const{unit:d,increment:m,roundingMode:u}=t;({hour:n,minute:r,second:s,millisecond:a,microsecond:c,nanosecond:h}=Yo(n,r,s,a,c,h,m,d,u))}return`${ue(n)}:${ue(r)}${xr(s,a,c,h,e)}`}class Ft{constructor(e=0,t=0,n=0,r=0,s=0,a=0){const c=ce(e),h=ce(t),d=ce(n),m=ce(r),u=ce(s),f=ce(a);Zr(c,h,d,m,u,f),It(this),H(this,Z,c),H(this,j,h),H(this,A,d),H(this,S,m),H(this,q,u),H(this,U,f),H(this,E,De())}get calendar(){if(!we(this))throw new TypeError("invalid receiver");return o(this,E)}get hour(){if(!we(this))throw new TypeError("invalid receiver");return o(this,Z)}get minute(){if(!we(this))throw new TypeError("invalid receiver");return o(this,j)}get second(){if(!we(this))throw new TypeError("invalid receiver");return o(this,A)}get millisecond(){if(!we(this))throw new TypeError("invalid receiver");return o(this,S)}get microsecond(){if(!we(this))throw new TypeError("invalid receiver");return o(this,q)}get nanosecond(){if(!we(this))throw new TypeError("invalid receiver");return o(this,U)}with(e,t){if(!we(this))throw new TypeError("invalid receiver");if(!he(e))throw new TypeError("invalid argument");On(e);const n=Le(z(t)),r=Ht(e,["hour","microsecond","millisecond","minute","nanosecond","second"]);if(!r)throw new TypeError("invalid time-like");const s=Eo(this);let{hour:a,minute:c,second:h,millisecond:d,microsecond:m,nanosecond:u}=ua(s,r);return{hour:a,minute:c,second:h,millisecond:d,microsecond:m,nanosecond:u}=Nn(a,c,h,d,m,u,n),new Ft(a,c,h,d,m,u)}add(e){if(!we(this))throw new TypeError("invalid receiver");const t=wt(e),{hours:n,minutes:r,seconds:s,milliseconds:a,microseconds:c,nanoseconds:h}=t;let d=o(this,Z),m=o(this,j),u=o(this,A),f=o(this,S),y=o(this,q),g=o(this,U);return{hour:d,minute:m,second:u,millisecond:f,microsecond:y,nanosecond:g}=co(d,m,u,f,y,g,n,r,s,a,c,h),{hour:d,minute:m,second:u,millisecond:f,microsecond:y,nanosecond:g}=Nn(d,m,u,f,y,g,"reject"),new Ft(d,m,u,f,y,g)}subtract(e){if(!we(this))throw new TypeError("invalid receiver");const t=wt(e),{hours:n,minutes:r,seconds:s,milliseconds:a,microseconds:c,nanoseconds:h}=t;let d=o(this,Z),m=o(this,j),u=o(this,A),f=o(this,S),y=o(this,q),g=o(this,U);return{hour:d,minute:m,second:u,millisecond:f,microsecond:y,nanosecond:g}=co(d,m,u,f,y,g,-n,-r,-s,-a,-c,-h),{hour:d,minute:m,second:u,millisecond:f,microsecond:y,nanosecond:g}=Nn(d,m,u,f,y,g,"reject"),new Ft(d,m,u,f,y,g)}until(e,t){if(!we(this))throw new TypeError("invalid receiver");const n=_t(e),r=z(t),s=ct(r,"auto",Yn,"hour"),a=Qe(r,"nanosecond",Yn);mt(s,a);const c=Me(r,"trunc"),h=ut(r,Qr[a],!1);let{hours:d,minutes:m,seconds:u,milliseconds:f,microseconds:y,nanoseconds:g}=so(o(this,Z),o(this,j),o(this,A),o(this,S),o(this,q),o(this,U),o(n,Z),o(n,j),o(n,A),o(n,S),o(n,q),o(n,U));return{hours:d,minutes:m,seconds:u,milliseconds:f,microseconds:y,nanoseconds:g}=ft(0,0,0,0,d,m,u,f,y,g,h,a,c),{hours:d,minutes:m,seconds:u,milliseconds:f,microseconds:y,nanoseconds:g}=xe(0,d,m,u,f,y,g,s),new(F("%Temporal.Duration%"))(0,0,0,0,d,m,u,f,y,g)}since(e,t){if(!we(this))throw new TypeError("invalid receiver");const n=_t(e),r=z(t),s=ct(r,"auto",Yn,"hour"),a=Qe(r,"nanosecond",Yn);mt(s,a);const c=Me(r,"trunc"),h=ut(r,Qr[a],!1);let{hours:d,minutes:m,seconds:u,milliseconds:f,microseconds:y,nanoseconds:g}=so(o(n,Z),o(n,j),o(n,A),o(n,S),o(n,q),o(n,U),o(this,Z),o(this,j),o(this,A),o(this,S),o(this,q),o(this,U));return{hours:d,minutes:m,seconds:u,milliseconds:f,microseconds:y,nanoseconds:g}=ft(0,0,0,0,-d,-m,-u,-f,-y,-g,h,a,Qn(c)),d=-d,m=-m,u=-u,f=-f,y=-y,g=-g,{hours:d,minutes:m,seconds:u,milliseconds:f,microseconds:y,nanoseconds:g}=xe(0,d,m,u,f,y,g,s),new(F("%Temporal.Duration%"))(0,0,0,0,d,m,u,f,y,g)}round(e){if(!we(this))throw new TypeError("invalid receiver");if(e===void 0)throw new TypeError("options parameter is required");const t=typeof e=="string"?bn("smallestUnit",e):z(e),n=Qe(t,void 0,Yn);if(n===void 0)throw new RangeError("smallestUnit is required");const r=Me(t,"halfExpand"),s=ut(t,Qr[n],!1);let a=o(this,Z),c=o(this,j),h=o(this,A),d=o(this,S),m=o(this,q),u=o(this,U);return{hour:a,minute:c,second:h,millisecond:d,microsecond:m,nanosecond:u}=Yo(a,c,h,d,m,u,s,n,r),new Ft(a,c,h,d,m,u)}equals(e){if(!we(this))throw new TypeError("invalid receiver");const t=_t(e);for(const n of[Z,j,A,S,q,U])if(o(this,n)!==o(t,n))return!1;return!0}toString(e){if(!we(this))throw new TypeError("invalid receiver");const t=z(e),{precision:n,unit:r,increment:s}=Jn(t);return hi(this,n,{unit:r,increment:s,roundingMode:Me(t,"trunc")})}toJSON(){if(!we(this))throw new TypeError("invalid receiver");return hi(this,"auto")}toLocaleString(e,t){if(!we(this))throw new TypeError("invalid receiver");return new Vt(e,t).format(this)}valueOf(){throw new TypeError("use compare() or equals() to compare Temporal.PlainTime")}toPlainDateTime(e){if(!we(this))throw new TypeError("invalid receiver");const t=ae(e),n=o(t,R),r=o(t,$),s=o(t,I),a=o(t,E);return tt(n,r,s,o(this,Z),o(this,j),o(this,A),o(this,S),o(this,q),o(this,U),a)}toZonedDateTime(e){if(!we(this))throw new TypeError("invalid receiver");if(!he(e))throw new TypeError("invalid argument");const t=e.plainDate;if(t===void 0)throw new TypeError("missing date property");const n=ae(t),r=e.timeZone;if(r===void 0)throw new TypeError("missing timeZone property");const s=et(r),a=o(n,R),c=o(n,$),h=o(n,I),d=o(n,E),m=o(this,Z),u=o(this,j),f=o(this,A),y=o(this,S),g=o(this,q),w=o(this,U);return Ne(o(Je(s,new(F("%Temporal.PlainDateTime%"))(a,c,h,m,u,f,y,g,w,d),"compatible"),P),s,d)}getISOFields(){if(!we(this))throw new TypeError("invalid receiver");return{calendar:o(this,E),isoHour:o(this,Z),isoMicrosecond:o(this,q),isoMillisecond:o(this,S),isoMinute:o(this,j),isoNanosecond:o(this,U),isoSecond:o(this,A)}}static from(e,t){const n=Le(z(t));return we(e)?new Ft(o(e,Z),o(e,j),o(e,A),o(e,S),o(e,q),o(e,U)):_t(e,n)}static compare(e,t){const n=_t(e),r=_t(t);for(const s of[Z,j,A,S,q,U]){const a=o(n,s),c=o(r,s);if(a!==c)return tn(a-c)}return 0}}kt(Ft,"Temporal.PlainTime");class xo{constructor(e){if(arguments.length<1)throw new RangeError("missing argument: identifier is required");const t=Oo(e);It(this),H(this,At,t)}get id(){if(!Dt(this))throw new TypeError("invalid receiver");return x(this)}getOffsetNanosecondsFor(e){if(!Dt(this))throw new TypeError("invalid receiver");const t=Et(e),n=o(this,At);return mn(n)?on(n):Nt(o(t,P),n)}getOffsetStringFor(e){if(!Dt(this))throw new TypeError("invalid receiver");return io(this,Et(e))}getPlainDateTimeFor(e,t=De()){return lt(this,Et(e),Ze(t))}getInstantFor(e,t){if(!Dt(this))throw new TypeError("invalid receiver");return Je(this,St(e),Sn(z(t)))}getPossibleInstantsFor(e){if(!Dt(this))throw new TypeError("invalid receiver");const t=St(e),n=F("%Temporal.Instant%"),r=o(this,At);if(mn(r)){const s=Wt(o(t,R),o(t,$),o(t,I),o(t,Z),o(t,j),o(t,A),o(t,S),o(t,q),o(t,U));if(s===null)throw new RangeError("DateTime outside of supported range");const a=on(r);return[new n(l.subtract(s,l.BigInt(a)))]}return function(a,c,h,d,m,u,f,y,g,w){const p=Wt(c,h,d,m,u,f,y,g,w);if(p===null)throw new RangeError("DateTime outside of supported range");let v=l.subtract(p,Gt);l.lessThan(v,Zn)&&(v=p);let T=l.add(p,Gt);l.greaterThan(T,jn)&&(T=p);const b=Nt(v,a),D=Nt(T,a);return(b===D?[b]:[b,D]).map(_=>{const C=l.subtract(p,l.BigInt(_)),M=zi(C,a);if(c===M.year&&h===M.month&&d===M.day&&m===M.hour&&u===M.minute&&f===M.second&&y===M.millisecond&&g===M.microsecond&&w===M.nanosecond)return C}).filter(_=>_!==void 0)}(r,o(t,R),o(t,$),o(t,I),o(t,Z),o(t,j),o(t,A),o(t,S),o(t,q),o(t,U)).map(s=>new n(s))}getNextTransition(e){if(!Dt(this))throw new TypeError("invalid receiver");const t=Et(e),n=o(this,At);if(mn(n)||n==="UTC")return null;let r=o(t,P);const s=F("%Temporal.Instant%");return r=function(c,h){const d=l.add(c,Mi),m=ii(Gi(),d);let u=ii(Ci,c);const f=Nt(u,h);let y=u,g=f;for(;f===g&&l.lessThan(l.BigInt(u),m);)y=l.add(u,Oi),g=Nt(y,h),f===g&&(u=y);return f===g?null:ts(w=>Nt(w,h),u,y,f,g)}(r,n),r===null?null:new s(r)}getPreviousTransition(e){if(!Dt(this))throw new TypeError("invalid receiver");const t=Et(e),n=o(this,At);if(mn(n)||n==="UTC")return null;let r=o(t,P);const s=F("%Temporal.Instant%");return r=Wi(r,n),r===null?null:new s(r)}toString(){if(!Dt(this))throw new TypeError("invalid receiver");return x(o(this,At))}toJSON(){if(!Dt(this))throw new TypeError("invalid receiver");return x(this)}static from(e){return et(e)}}kt(xo,"Temporal.TimeZone");const ma=Object.create,lr=["week","day","hour","minute","second","millisecond","microsecond","nanosecond"];class Zo{constructor(e,t,n=De(),r=1){const s=ce(e),a=ce(t),c=Ze(n),h=ce(r);if(arguments.length<2)throw new RangeError("missing argument: isoYear and isoMonth are required");Zi(this,s,a,c,h)}get year(){if(!te(this))throw new TypeError("invalid receiver");return $r(o(this,E),this)}get month(){if(!te(this))throw new TypeError("invalid receiver");return kr(o(this,E),this)}get monthCode(){if(!te(this))throw new TypeError("invalid receiver");return tr(o(this,E),this)}get calendar(){if(!te(this))throw new TypeError("invalid receiver");return o(this,E)}get era(){if(!te(this))throw new TypeError("invalid receiver");return Yr(o(this,E),this)}get eraYear(){if(!te(this))throw new TypeError("invalid receiver");return Nr(o(this,E),this)}get daysInMonth(){if(!te(this))throw new TypeError("invalid receiver");return yn(o(this,E),this)}get daysInYear(){if(!te(this))throw new TypeError("invalid receiver");return Pr(o(this,E),this)}get monthsInYear(){if(!te(this))throw new TypeError("invalid receiver");return Lr(o(this,E),this)}get inLeapYear(){if(!te(this))throw new TypeError("invalid receiver");return Fr(o(this,E),this)}with(e,t){if(!te(this))throw new TypeError("invalid receiver");if(!he(e))throw new TypeError("invalid argument");On(e);const n=o(this,E),r=ve(n,["month","monthCode","year"]),s=Ht(e,r);if(!s)throw new TypeError("invalid year-month-like");let a=rt(this,r);return a=rn(n,a,s),a=rt(a,r),zt(n,a,z(t))}add(e,t){if(!te(this))throw new TypeError("invalid receiver");const n=wt(e);let{years:r,months:s,weeks:a,days:c,hours:h,minutes:d,seconds:m,milliseconds:u,microseconds:f,nanoseconds:y}=n;({days:c}=xe(c,h,d,m,u,f,y,"day"));const g=z(t),w=o(this,E),p=ve(w,["monthCode","year"]),v=Tt(w,{...rt(this,p),day:gt(r,s,a,c,0,0,0,0,0,0)<0?pn(yn(w,this)):1}),T={...g};return zt(w,rt(Xe(w,v,{...n,days:c},g),p),T)}subtract(e,t){if(!te(this))throw new TypeError("invalid receiver");let n=wt(e);n={years:-n.years,months:-n.months,weeks:-n.weeks,days:-n.days,hours:-n.hours,minutes:-n.minutes,seconds:-n.seconds,milliseconds:-n.milliseconds,microseconds:-n.microseconds,nanoseconds:-n.nanoseconds};let{years:r,months:s,weeks:a,days:c,hours:h,minutes:d,seconds:m,milliseconds:u,microseconds:f,nanoseconds:y}=n;({days:c}=xe(c,h,d,m,u,f,y,"day"));const g=z(t),w=o(this,E),p=ve(w,["monthCode","year"]),v=Tt(w,{...rt(this,p),day:gt(r,s,a,c,0,0,0,0,0,0)<0?pn(yn(w,this)):1}),T={...g};return zt(w,rt(Xe(w,v,{...n,days:c},g),p),T)}until(e,t){if(!te(this))throw new TypeError("invalid receiver");const n=ln(e),r=o(this,E),s=o(n,E),a=x(r),c=x(s);if(a!==c)throw new RangeError(`cannot compute difference between months of ${a} and ${c} calendars`);const h=z(t),d=Qe(h,"month",lr),m=ct(h,"auto",lr,"year");mt(m,d);const u=Me(h,"trunc"),f=ut(h,void 0,!1),y=ve(r,["monthCode","year"]),g=rt(n,y),w=rt(this,y),p=Tt(r,{...g,day:1}),v=Tt(r,{...w,day:1}),T=Mt(r,v,p,{...h,largestUnit:m});if(d==="month"&&f===1)return T;let{years:b,months:D}=T;return{years:b,months:D}=ft(b,D,0,0,0,0,0,0,0,0,f,d,u,v),new(F("%Temporal.Duration%"))(b,D,0,0,0,0,0,0,0,0)}since(e,t){if(!te(this))throw new TypeError("invalid receiver");const n=ln(e),r=o(this,E),s=o(n,E),a=x(r),c=x(s);if(a!==c)throw new RangeError(`cannot compute difference between months of ${a} and ${c} calendars`);const h=z(t),d=Qe(h,"month",lr),m=ct(h,"auto",lr,"year");mt(m,d);const u=Me(h,"trunc"),f=ut(h,void 0,!1),y=ve(r,["monthCode","year"]),g=rt(n,y),w=rt(this,y),p=Tt(r,{...g,day:1}),v=Tt(r,{...w,day:1}),T={...h,largestUnit:m};let{years:b,months:D}=Mt(r,v,p,T);const _=F("%Temporal.Duration%");return d==="month"&&f===1||({years:b,months:D}=ft(b,D,0,0,0,0,0,0,0,0,f,d,Qn(u),v)),new _(-b,-D,0,0,0,0,0,0,0,0)}equals(e){if(!te(this))throw new TypeError("invalid receiver");const t=ln(e);for(const n of[R,$,I])if(o(this,n)!==o(t,n))return!1;return nr(o(this,E),o(t,E))}toString(e){if(!te(this))throw new TypeError("invalid receiver");return ri(this,Kn(z(e)))}toJSON(){if(!te(this))throw new TypeError("invalid receiver");return ri(this)}toLocaleString(e,t){if(!te(this))throw new TypeError("invalid receiver");return new Vt(e,t).format(this)}valueOf(){throw new TypeError("use compare() or equals() to compare Temporal.PlainYearMonth")}toPlainDate(e){if(!te(this))throw new TypeError("invalid receiver");if(!he(e))throw new TypeError("argument should be an object");const t=o(this,E),n=ve(t,["monthCode","year"]),r=rt(this,n),s=ve(t,["day"]),a=[["day"]];s.forEach(u=>{a.some(([f])=>f===u)||a.push([u,void 0])});let c=rn(t,r,Fe(e,a));const h=[...new Set([...n,...s])],d=[];h.forEach(u=>{d.some(([f])=>f===u)||d.push([u,void 0])}),c=Fe(c,d);const m=ma(null);return m.overflow="reject",Tt(t,c,m)}getISOFields(){if(!te(this))throw new TypeError("invalid receiver");return{calendar:o(this,E),isoDay:o(this,I),isoMonth:o(this,$),isoYear:o(this,R)}}static from(e,t){const n=z(t);return te(e)?(Le(n),zn(o(e,R),o(e,$),o(e,E),o(e,I))):ln(e,n)}static compare(e,t){const n=ln(e),r=ln(t);return Lt(o(n,R),o(n,$),o(n,I),o(r,R),o(r,$),o(r,I))}}kt(Zo,"Temporal.PlainYearMonth");const fa=Array.prototype.push;class jo{constructor(e,t,n=De()){if(arguments.length<1)throw new TypeError("missing argument: epochNanoseconds is required");ji(this,Pn(e),et(t),Ze(n))}get calendar(){if(!Y(this))throw new TypeError("invalid receiver");return o(this,E)}get timeZone(){if(!Y(this))throw new TypeError("invalid receiver");return o(this,J)}get year(){if(!Y(this))throw new TypeError("invalid receiver");return $r(o(this,E),de(this))}get month(){if(!Y(this))throw new TypeError("invalid receiver");return kr(o(this,E),de(this))}get monthCode(){if(!Y(this))throw new TypeError("invalid receiver");return tr(o(this,E),de(this))}get day(){if(!Y(this))throw new TypeError("invalid receiver");return Ir(o(this,E),de(this))}get hour(){if(!Y(this))throw new TypeError("invalid receiver");return o(de(this),Z)}get minute(){if(!Y(this))throw new TypeError("invalid receiver");return o(de(this),j)}get second(){if(!Y(this))throw new TypeError("invalid receiver");return o(de(this),A)}get millisecond(){if(!Y(this))throw new TypeError("invalid receiver");return o(de(this),S)}get microsecond(){if(!Y(this))throw new TypeError("invalid receiver");return o(de(this),q)}get nanosecond(){if(!Y(this))throw new TypeError("invalid receiver");return o(de(this),U)}get era(){if(!Y(this))throw new TypeError("invalid receiver");return Yr(o(this,E),de(this))}get eraYear(){if(!Y(this))throw new TypeError("invalid receiver");return Nr(o(this,E),de(this))}get epochSeconds(){if(!Y(this))throw new TypeError("invalid receiver");const e=o(this,P);return l.toNumber(l.divide(e,Zt))}get epochMilliseconds(){if(!Y(this))throw new TypeError("invalid receiver");const e=o(this,P);return l.toNumber(l.divide(e,dt))}get epochMicroseconds(){if(!Y(this))throw new TypeError("invalid receiver");const e=o(this,P);return Mr(l.divide(e,re))}get epochNanoseconds(){if(!Y(this))throw new TypeError("invalid receiver");return Mr(o(this,P))}get dayOfWeek(){if(!Y(this))throw new TypeError("invalid receiver");return bo(o(this,E),de(this))}get dayOfYear(){if(!Y(this))throw new TypeError("invalid receiver");return Do(o(this,E),de(this))}get weekOfYear(){if(!Y(this))throw new TypeError("invalid receiver");return _o(o(this,E),de(this))}get hoursInDay(){if(!Y(this))throw new TypeError("invalid receiver");const e=de(this),t=F("%Temporal.PlainDateTime%"),n=o(e,R),r=o(e,$),s=o(e,I),a=new t(n,r,s,0,0,0,0,0,0),c=en(n,r,s,0,0,0,1,"reject"),h=new t(c.year,c.month,c.day,0,0,0,0,0,0),d=o(this,J),m=o(Je(d,a,"compatible"),P),u=o(Je(d,h,"compatible"),P);return l.toNumber(l.subtract(u,m))/36e11}get daysInWeek(){if(!Y(this))throw new TypeError("invalid receiver");return Co(o(this,E),de(this))}get daysInMonth(){if(!Y(this))throw new TypeError("invalid receiver");return yn(o(this,E),de(this))}get daysInYear(){if(!Y(this))throw new TypeError("invalid receiver");return Pr(o(this,E),de(this))}get monthsInYear(){if(!Y(this))throw new TypeError("invalid receiver");return Lr(o(this,E),de(this))}get inLeapYear(){if(!Y(this))throw new TypeError("invalid receiver");return Fr(o(this,E),de(this))}get offset(){if(!Y(this))throw new TypeError("invalid receiver");return io(o(this,J),o(this,je))}get offsetNanoseconds(){if(!Y(this))throw new TypeError("invalid receiver");return bt(o(this,J),o(this,je))}with(e,t){if(!Y(this))throw new TypeError("invalid receiver");if(!he(e))throw new TypeError("invalid zoned-date-time-like");On(e);const n=z(t),r=Sn(n),s=no(n,"prefer"),a=o(this,J),c=o(this,E),h=ve(c,["day","hour","microsecond","millisecond","minute","month","monthCode","nanosecond","second","year"]);fa.call(h,"offset");const d=Ht(e,h);if(!d)throw new TypeError("invalid zoned-date-time-like");const m=[["day",void 0],["hour",0],["microsecond",0],["millisecond",0],["minute",0],["month",void 0],["monthCode",void 0],["nanosecond",0],["second",0],["year",void 0],["offset"],["timeZone"]];h.forEach(_=>{m.some(([C])=>C===_)||m.push([_,void 0])});let u=Fe(this,m);u=rn(c,u,d),u=Fe(u,m);const{year:f,month:y,day:g,hour:w,minute:p,second:v,millisecond:T,microsecond:b,nanosecond:D}=er(c,u,n);return Ne(vr(f,y,g,w,p,v,T,b,D,"option",on(u.offset),a,r,s,!1),o(this,J),c)}withPlainDate(e){if(!Y(this))throw new TypeError("invalid receiver");const t=ae(e),n=o(t,R),r=o(t,$),s=o(t,I);let a=o(t,E);const c=de(this),h=o(c,Z),d=o(c,j),m=o(c,A),u=o(c,S),f=o(c,q),y=o(c,U);a=Ai(o(this,E),a);const g=o(this,J);return Ne(o(Je(g,new(F("%Temporal.PlainDateTime%"))(n,r,s,h,d,m,u,f,y,a),"compatible"),P),g,a)}withPlainTime(e){if(!Y(this))throw new TypeError("invalid receiver");const t=F("%Temporal.PlainTime%"),n=e==null?new t:_t(e),r=de(this),s=o(r,R),a=o(r,$),c=o(r,I),h=o(this,E),d=o(n,Z),m=o(n,j),u=o(n,A),f=o(n,S),y=o(n,q),g=o(n,U),w=o(this,J);return Ne(o(Je(w,new(F("%Temporal.PlainDateTime%"))(s,a,c,d,m,u,f,y,g,h),"compatible"),P),w,h)}withTimeZone(e){if(!Y(this))throw new TypeError("invalid receiver");const t=et(e);return Ne(o(this,P),t,o(this,E))}withCalendar(e){if(!Y(this))throw new TypeError("invalid receiver");const t=Ze(e);return Ne(o(this,P),o(this,J),t)}add(e,t){if(!Y(this))throw new TypeError("invalid receiver");const n=wt(e),{years:r,months:s,weeks:a,days:c,hours:h,minutes:d,seconds:m,milliseconds:u,microseconds:f,nanoseconds:y}=n,g=z(t),w=o(this,J),p=o(this,E);return Ne(at(o(this,je),w,p,r,s,a,c,h,d,m,u,f,y,g),w,p)}subtract(e,t){if(!Y(this))throw new TypeError("invalid receiver");const n=wt(e),{years:r,months:s,weeks:a,days:c,hours:h,minutes:d,seconds:m,milliseconds:u,microseconds:f,nanoseconds:y}=n,g=z(t),w=o(this,J),p=o(this,E);return Ne(at(o(this,je),w,p,-r,-s,-a,-c,-h,-d,-m,-u,-f,-y,g),w,p)}until(e,t){if(!Y(this))throw new TypeError("invalid receiver");const n=hn(e),r=o(this,E),s=o(n,E),a=x(r),c=x(s);if(a!==c)throw new RangeError(`cannot compute difference between dates of ${a} and ${c} calendars`);const h=z(t),d=Qe(h,"nanosecond"),m=ct(h,"auto",[],pt("hour",d));mt(m,d);const u=Me(h,"trunc"),f=qn(h,d),y=o(this,P),g=o(n,P);let w,p,v,T,b,D,_,C,M,k;if(m!=="year"&&m!=="month"&&m!=="week"&&m!=="day")w=0,p=0,v=0,T=0,{seconds:_,milliseconds:C,microseconds:M,nanoseconds:k}=Wn(y,g,f,d,u),{hours:b,minutes:D,seconds:_,milliseconds:C,microseconds:M,nanoseconds:k}=xe(0,0,0,_,C,M,k,m);else{const N=o(this,J);if(!Wr(N,o(n,J)))throw new RangeError("When calculating difference between time zones, largestUnit must be 'hours' or smaller because day lengths can vary between time zones due to DST or time zone offset changes.");const K={...h,largestUnit:m};({years:w,months:p,weeks:v,days:T,hours:b,minutes:D,seconds:_,milliseconds:C,microseconds:M,nanoseconds:k}=ao(y,g,N,r,m,K)),{years:w,months:p,weeks:v,days:T,hours:b,minutes:D,seconds:_,milliseconds:C,microseconds:M,nanoseconds:k}=ft(w,p,v,T,b,D,_,C,M,k,f,d,u,this),{years:w,months:p,weeks:v,days:T,hours:b,minutes:D,seconds:_,milliseconds:C,microseconds:M,nanoseconds:k}=uo(w,p,v,T,b,D,_,C,M,k,f,d,u,this)}return new(F("%Temporal.Duration%"))(w,p,v,T,b,D,_,C,M,k)}since(e,t){if(!Y(this))throw new TypeError("invalid receiver");const n=hn(e),r=o(this,E),s=o(n,E),a=x(r),c=x(s);if(a!==c)throw new RangeError(`cannot compute difference between dates of ${a} and ${c} calendars`);const h=z(t),d=Qe(h,"nanosecond"),m=ct(h,"auto",[],pt("hour",d));mt(m,d);let u=Me(h,"trunc");u=Qn(u);const f=qn(h,d),y=o(this,P),g=o(n,P);let w,p,v,T,b,D,_,C,M,k;if(m!=="year"&&m!=="month"&&m!=="week"&&m!=="day")w=0,p=0,v=0,T=0,{seconds:_,milliseconds:C,microseconds:M,nanoseconds:k}=Wn(y,g,f,d,u),{hours:b,minutes:D,seconds:_,milliseconds:C,microseconds:M,nanoseconds:k}=xe(0,0,0,_,C,M,k,m);else{const N=o(this,J);if(!Wr(N,o(n,J)))throw new RangeError("When calculating difference between time zones, largestUnit must be 'hours' or smaller because day lengths can vary between time zones due to DST or time zone offset changes.");const K={...h,largestUnit:m};({years:w,months:p,weeks:v,days:T,hours:b,minutes:D,seconds:_,milliseconds:C,microseconds:M,nanoseconds:k}=ao(y,g,N,r,m,K)),{years:w,months:p,weeks:v,days:T,hours:b,minutes:D,seconds:_,milliseconds:C,microseconds:M,nanoseconds:k}=ft(w,p,v,T,b,D,_,C,M,k,f,d,u,this),{years:w,months:p,weeks:v,days:T,hours:b,minutes:D,seconds:_,milliseconds:C,microseconds:M,nanoseconds:k}=uo(w,p,v,T,b,D,_,C,M,k,f,d,u,this)}return new(F("%Temporal.Duration%"))(-w,-p,-v,-T,-b,-D,-_,-C,-M,-k)}round(e){if(!Y(this))throw new TypeError("invalid receiver");if(e===void 0)throw new TypeError("options parameter is required");const t=typeof e=="string"?bn("smallestUnit",e):z(e),n=Qe(t,void 0,["year","month","week"]);if(n===void 0)throw new RangeError("smallestUnit is required");const r=Me(t,"halfExpand"),s=ut(t,{day:1,hour:24,minute:60,second:60,millisecond:1e3,microsecond:1e3,nanosecond:1e3}[n],!1),a=de(this);let c=o(a,R),h=o(a,$),d=o(a,I),m=o(a,Z),u=o(a,j),f=o(a,A),y=o(a,S),g=o(a,q),w=o(a,U);const p=F("%Temporal.PlainDateTime%"),v=o(this,J),T=o(this,E),b=Je(v,new p(o(a,R),o(a,$),o(a,I),0,0,0,0,0,0),"compatible"),D=at(b,v,T,0,0,0,1,0,0,0,0,0,0),_=l.subtract(D,l.BigInt(o(b,P)));if(l.equal(_,be))throw new RangeError("cannot round a ZonedDateTime in a calendar with zero-length days");return{year:c,month:h,day:d,hour:m,minute:u,second:f,millisecond:y,microsecond:g,nanosecond:w}=Io(c,h,d,m,u,f,y,g,w,s,n,r,l.toNumber(_)),Ne(vr(c,h,d,m,u,f,y,g,w,"option",bt(v,o(this,je)),v,"compatible","prefer",!1),v,o(this,E))}equals(e){if(!Y(this))throw new TypeError("invalid receiver");const t=hn(e),n=o(this,P),r=o(t,P);return!!l.equal(l.BigInt(n),l.BigInt(r))&&!!Wr(o(this,J),o(t,J))&&nr(o(this,E),o(t,E))}toString(e){if(!Y(this))throw new TypeError("invalid receiver");const t=z(e),{precision:n,unit:r,increment:s}=Jn(t),a=Me(t,"trunc");return oi(this,n,Kn(t),function(h){return Rt(h,"timeZoneName",["auto","never"],"auto")}(t),function(h){return Rt(h,"offset",["auto","never"],"auto")}(t),{unit:r,increment:s,roundingMode:a})}toLocaleString(e,t){if(!Y(this))throw new TypeError("invalid receiver");return new Vt(e,t).format(this)}toJSON(){if(!Y(this))throw new TypeError("invalid receiver");return oi(this,"auto")}valueOf(){throw new TypeError("use compare() or equals() to compare Temporal.ZonedDateTime")}startOfDay(){if(!Y(this))throw new TypeError("invalid receiver");const e=de(this),t=F("%Temporal.PlainDateTime%"),n=o(this,E),r=new t(o(e,R),o(e,$),o(e,I),0,0,0,0,0,0,n),s=o(this,J);return Ne(o(Je(s,r,"compatible"),P),s,n)}toInstant(){if(!Y(this))throw new TypeError("invalid receiver");return new(F("%Temporal.Instant%"))(o(this,P))}toPlainDate(){if(!Y(this))throw new TypeError("invalid receiver");return Jt(de(this))}toPlainTime(){if(!Y(this))throw new TypeError("invalid receiver");return Mo(de(this))}toPlainDateTime(){if(!Y(this))throw new TypeError("invalid receiver");return de(this)}toPlainYearMonth(){if(!Y(this))throw new TypeError("invalid receiver");const e=o(this,E);return zt(e,rt(this,ve(e,["monthCode","year"])))}toPlainMonthDay(){if(!Y(this))throw new TypeError("invalid receiver");const e=o(this,E);return Tn(e,Kt(this,ve(e,["day","monthCode"])))}getISOFields(){if(!Y(this))throw new TypeError("invalid receiver");const e=de(this),t=o(this,J);return{calendar:o(this,E),isoDay:o(e,I),isoHour:o(e,Z),isoMicrosecond:o(e,q),isoMillisecond:o(e,S),isoMinute:o(e,j),isoMonth:o(e,$),isoNanosecond:o(e,U),isoSecond:o(e,A),isoYear:o(e,R),offset:io(t,o(this,je)),timeZone:t}}static from(e,t){const n=z(t);return Y(e)?(Le(n),Sn(n),no(n,"reject"),Ne(o(e,P),o(e,J),o(e,E))):hn(e,n)}static compare(e,t){const n=hn(e),r=hn(t),s=o(n,P),a=o(r,P);return l.lessThan(l.BigInt(s),l.BigInt(a))?-1:l.greaterThan(l.BigInt(s),l.BigInt(a))?1:0}}function de(i){return lt(o(i,J),o(i,je),o(i,E))}kt(jo,"Temporal.ZonedDateTime");var Ao=Object.freeze({__proto__:null,Instant:ht,Calendar:fr,PlainDate:or,PlainDateTime:ir,Duration:Ct,PlainMonthDay:Lo,Now:ds,PlainTime:Ft,TimeZone:xo,PlainYearMonth:Zo,ZonedDateTime:jo});const ya=[ht,fr,or,ir,Ct,Lo,Ft,xo,Zo,jo];for(const i of ya){const e=Object.getOwnPropertyDescriptor(i,"prototype");(e.configurable||e.enumerable||e.writable)&&(e.configurable=!1,e.enumerable=!1,e.writable=!1,Object.defineProperty(i,"prototype",e))}const So="de",ga={years:["Jahr","Jahre"],months:["Monat","Monate"],weeks:["Woche","Wochen"],days:["Tag","Tage"],hours:["Stunde","Stunden"],minutes:["Minute","Minuten"],seconds:["Sekunde","Sekunden"]};function qo(i,e){return ga[i][e==1?0:1]}function Uo(i,e){return e.map(t=>{const n=i[t];return`${n.toLocaleString(So)} ${qo(t,n)}`}).join(", ")}function wa(i,e,t){return e.toLocaleString("de")+" "+qo(i,e)+" alt: "+t.toLocaleString(So,{dateStyle:"long",timeStyle:"short"})}const us="Europe/Berlin",_n=Ao.ZonedDateTime.from({timeZone:us,year:2021,month:9,day:16,hour:16,minute:9}),Sr=Ao.Now.zonedDateTimeISO(us),sr=[],pa=_n.until(Sr,{largestUnit:"years"});sr.push(Uo(pa,["years","months","days"]));const va=_n.until(Sr,{largestUnit:"weeks"});sr.push(Uo(va,["weeks","days"]));const Ta=_n.until(Sr,{largestUnit:"days"});sr.push(Uo(Ta,["days","hours","minutes"]));const di=_n.until(Sr).total({unit:"years",relativeTo:_n});sr.push(di.toLocaleString(So)+" "+qo("years",di));const Ea=[["seconds",1e7],["hours",1e4],["minutes",1e6],["weeks",100],["days",1e3]],ba=Ea.map(([i,e])=>wa(i,e,_n.add(Ao.Duration.from({[i]:e}))));function ms(i,e,t){t.forEach(n=>{const r=document.createElement(e);r.innerText=n,i.appendChild(r)})}const Da=document.querySelector("#durations");ms(Da,"li",sr);const _a=document.querySelector("#dates");ms(_a,"li",ba);
